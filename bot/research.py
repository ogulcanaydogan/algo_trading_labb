"""Tools for exploring strategy parameters and macro-aware scenarios.

This module helps answer the user's request for "trying every possibility" by
providing a light-weight brute force search across indicator settings.  It does
not require live exchange connectivity – synthetic candles or CSV exports are
enough to get started – but it still reuses the production strategy logic so
results remain comparable to the live bot.

Example
-------
Run a quick search against synthetic data (generated by :class:`PaperExchangeClient`)
to see which EMA/RSI combination works best under the default macro backdrop::

    python -m bot.research --symbol BTC/USDT --timeframe 1m --ema-fast 8,12,16 \
        --ema-slow 21,26,34 --rsi-overbought 65,70 --rsi-oversold 25,30

If you already have a CSV dump with ``timestamp,open,high,low,close,volume``
columns, point the searcher at the file and provide an optional macro events
feed::

    python -m bot.research --csv data/sample_ohlcv.csv --macro-events data/macro_events.sample.json

The script prints the best ranked configurations along with descriptive
performance metrics that you can plug back into ``.env`` or the dashboard.
"""

from __future__ import annotations

import argparse
import math
import statistics
from dataclasses import dataclass, field
from pathlib import Path
from typing import Iterable, List, Sequence

import numpy as np
import pandas as pd

from .exchange import PaperExchangeClient
from .macro import MacroInsight, MacroSentimentEngine
from .strategy import StrategyConfig, compute_indicators, generate_signal


# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------


@dataclass
class StrategySearchRequest:
    """Parameters controlling the brute force search."""

    symbol: str = "BTC/USDT"
    timeframe: str = "1m"
    lookback: int = 500
    ema_fast_values: Sequence[int] = (8, 12, 16)
    ema_slow_values: Sequence[int] = (21, 26, 34)
    rsi_overbought_values: Sequence[float] = (65.0, 70.0)
    rsi_oversold_values: Sequence[float] = (25.0, 30.0)
    csv_path: Path | None = None
    macro_events_path: Path | None = None
    macro_refresh_seconds: int = 300
    top_n: int = 5


@dataclass(order=True)
class StrategySearchResult:
    """Outcome of a single configuration evaluation."""

    score: float
    total_return_pct: float
    sharpe_ratio: float
    win_rate: float
    max_drawdown_pct: float
    trades: int
    config: StrategyConfig = field(compare=False)
    macro_bias: float = field(default=0.0, compare=False)
    macro_summary: str | None = field(default=None, compare=False)

    def describe(self) -> str:
        """Human readable summary used by the CLI."""
        # Keep each printed line under the configured max line length
        lines = [
            f"EMA {self.config.ema_fast}/{self.config.ema_slow} | RSI {self.config.rsi_oversold}-"
            f"{self.config.rsi_overbought}",
            f"Return: {self.total_return_pct:+.2f}% | Sharpe: {self.sharpe_ratio:.2f}",
            f"Win rate: {self.win_rate:.1f}% | Trades: {self.trades}",
            f"Max drawdown: {self.max_drawdown_pct:.2f}% | Macro bias: {self.macro_bias:+.2f}",
        ]
        if self.macro_summary:
            lines.append(f"Macro: {self.macro_summary}")
        return "\n".join(lines)


# ---------------------------------------------------------------------------
# Core search utilities
# ---------------------------------------------------------------------------


def load_ohlcv(request: StrategySearchRequest) -> pd.DataFrame:
    """Load OHLCV data from a CSV file or generate a synthetic sample."""

    if request.csv_path is not None:
        frame = pd.read_csv(request.csv_path, parse_dates=["timestamp"], index_col="timestamp")
        required = {"open", "high", "low", "close", "volume"}
        if not required.issubset(frame.columns):
            missing = ", ".join(sorted(required - set(frame.columns)))
            raise ValueError(f"CSV is missing required columns: {missing}")
        return frame.tail(request.lookback)

    client = PaperExchangeClient(symbol=request.symbol, timeframe=request.timeframe)
    return client.fetch_ohlcv(limit=request.lookback)


def build_macro_engine(request: StrategySearchRequest) -> MacroSentimentEngine | None:
    if request.macro_events_path is None:
        return None
    return MacroSentimentEngine(
        events_path=request.macro_events_path,
        refresh_interval=request.macro_refresh_seconds,
    )


def generate_parameter_space(request: StrategySearchRequest) -> Iterable[StrategyConfig]:
    """Yield :class:`StrategyConfig` combinations respecting logical ordering."""

    for ema_fast in request.ema_fast_values:
        for ema_slow in request.ema_slow_values:
            if ema_fast >= ema_slow:
                continue
            for rsi_overbought in request.rsi_overbought_values:
                for rsi_oversold in request.rsi_oversold_values:
                    if rsi_overbought <= rsi_oversold:
                        continue
                    yield StrategyConfig(
                        symbol=request.symbol,
                        timeframe=request.timeframe,
                        ema_fast=ema_fast,
                        ema_slow=ema_slow,
                        rsi_overbought=rsi_overbought,
                        rsi_oversold=rsi_oversold,
                    )


def backtest_strategy(
    enriched: pd.DataFrame, config: StrategyConfig
) -> tuple[List[float], List[float]]:
    """Simulate trades using the live decision engine.

    Returns a tuple of (equity_curve, trade_returns).  ``equity_curve`` stores
    the equity value after each bar (starting at 1.0), while ``trade_returns``
    keeps the percentage gain/loss for every completed trade.
    """

    position = 0  # 1 long, -1 short, 0 flat
    entry_price: float | None = None
    balance = 1.0
    equity_curve: List[float] = [balance]
    trade_returns: List[float] = []

    timestamps = list(enriched.index)

    for idx in range(2, len(enriched)):
        window = enriched.iloc[: idx + 1]
        signal = generate_signal(window, config)
        price = float(window.iloc[-1]["close"])

        def close_trade(current_price: float) -> None:
            nonlocal balance, position, entry_price
            if position == 0 or entry_price is None:
                return
            if position == 1:
                ret = (current_price - entry_price) / entry_price
            else:
                ret = (entry_price - current_price) / entry_price
            balance *= 1 + ret
            trade_returns.append(ret)
            position = 0
            entry_price = None

        decision = signal["decision"]

        if decision == "LONG":
            if position == -1:
                close_trade(price)
            if position != 1:
                position = 1
                entry_price = price
        elif decision == "SHORT":
            if position == 1:
                close_trade(price)
            if position != -1:
                position = -1
                entry_price = price
        else:  # FLAT
            close_trade(price)

        equity_curve.append(balance if entry_price is None else balance)

    # Close any open trade at the final price
    if position != 0 and entry_price is not None:
        final_price = float(enriched.iloc[-1]["close"])
        if position == 1:
            ret = (final_price - entry_price) / entry_price
        else:
            ret = (entry_price - final_price) / entry_price
        balance *= 1 + ret
        trade_returns.append(ret)
        equity_curve[-1] = balance

    # Align curve length with timestamps for downstream analytics
    if len(equity_curve) < len(timestamps):
        equity_curve.extend([balance] * (len(timestamps) - len(equity_curve)))

    return equity_curve, trade_returns


def calculate_metrics(
    equity_curve: Sequence[float],
    trade_returns: Sequence[float],
) -> tuple[float, float, float, float, int]:
    """Compute aggregated metrics for ranking purposes."""

    if not equity_curve:
        return 0.0, 0.0, 0.0, 0.0, 0

    total_return_pct = (equity_curve[-1] - equity_curve[0]) / equity_curve[0] * 100

    if trade_returns:
        wins = sum(1 for value in trade_returns if value > 0)
        win_rate = wins / len(trade_returns) * 100
        try:
            sharpe = (
                statistics.mean(trade_returns) / statistics.pstdev(trade_returns) * math.sqrt(252)
            )
        except statistics.StatisticsError:
            sharpe = 0.0
    else:
        win_rate = 0.0
        sharpe = 0.0

    curve = np.array(equity_curve)
    running_max = np.maximum.accumulate(curve)
    drawdowns = (curve - running_max) / running_max
    max_drawdown_pct = float(drawdowns.min() * 100)

    return total_return_pct, sharpe, win_rate, max_drawdown_pct, len(trade_returns)


def score_result(total_return: float, sharpe: float, win_rate: float, macro_bias: float) -> float:
    """Blend financial metrics with macro awareness for ranking."""

    return total_return + sharpe * 5 + win_rate * 0.2 + macro_bias * 10


def search(request: StrategySearchRequest) -> List[StrategySearchResult]:
    """Run the brute force search across the configured parameter ranges."""

    ohlcv = load_ohlcv(request)
    macro_engine = build_macro_engine(request)
    macro: MacroInsight | None = None
    if macro_engine is not None:
        try:
            macro = macro_engine.assess(request.symbol)
        except Exception:
            macro = None

    results: List[StrategySearchResult] = []

    for config in generate_parameter_space(request):
        try:
            enriched = compute_indicators(ohlcv, config)
        except ValueError:
            continue

        equity_curve, trade_returns = backtest_strategy(enriched, config)
        (
            total_return,
            sharpe,
            win_rate,
            max_drawdown,
            trades,
        ) = calculate_metrics(equity_curve, trade_returns)

        macro_bias = macro.bias_score if macro else 0.0
        macro_summary = macro.summary if macro else None
        result = StrategySearchResult(
            score=score_result(total_return, sharpe, win_rate, macro_bias),
            total_return_pct=total_return,
            sharpe_ratio=sharpe,
            win_rate=win_rate,
            max_drawdown_pct=max_drawdown,
            trades=trades,
            config=config,
            macro_bias=macro_bias,
            macro_summary=macro_summary,
        )
        results.append(result)

    return sorted(results, reverse=True)


# ---------------------------------------------------------------------------
# CLI entry point
# ---------------------------------------------------------------------------


def parse_range(payload: str, *, value_type=float) -> List:
    items = [value.strip() for value in payload.split(",") if value.strip()]
    return [value_type(item) for item in items]


def build_argument_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Search EMA/RSI combinations using the live strategy logic."
    )
    parser.add_argument("--symbol", default="BTC/USDT", help="Target trading pair symbol.")
    parser.add_argument("--timeframe", default="1m", help="Candle timeframe (e.g. 1m, 5m).")
    parser.add_argument("--lookback", type=int, default=500, help="Number of candles to evaluate.")
    parser.add_argument(
        "--csv", dest="csv_path", type=Path, help="Optional CSV file with OHLCV data."
    )
    parser.add_argument(
        "--ema-fast",
        default="8,12,16",
        help="Comma separated EMA fast windows.",
    )
    parser.add_argument(
        "--ema-slow",
        default="21,26,34",
        help="Comma separated EMA slow windows.",
    )
    parser.add_argument(
        "--rsi-overbought",
        default="65,70",
        help="Comma separated RSI overbought levels.",
    )
    parser.add_argument(
        "--rsi-oversold",
        default="25,30",
        help="Comma separated RSI oversold levels.",
    )
    parser.add_argument(
        "--macro-events",
        dest="macro_events_path",
        type=Path,
        help="Optional JSON file describing macro catalysts.",
    )
    parser.add_argument(
        "--macro-refresh-seconds",
        dest="macro_refresh_seconds",
        type=int,
        default=300,
        help="How frequently to reload macro events during the search.",
    )
    parser.add_argument(
        "--top", dest="top_n", type=int, default=5, help="Number of results to display."
    )
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_argument_parser()
    args = parser.parse_args(argv)

    request = StrategySearchRequest(
        symbol=args.symbol,
        timeframe=args.timeframe,
        lookback=args.lookback,
        ema_fast_values=tuple(parse_range(args.ema_fast, value_type=int)),
        ema_slow_values=tuple(parse_range(args.ema_slow, value_type=int)),
        rsi_overbought_values=tuple(parse_range(args.rsi_overbought, value_type=float)),
        rsi_oversold_values=tuple(parse_range(args.rsi_oversold, value_type=float)),
        csv_path=args.csv_path,
        macro_events_path=args.macro_events_path,
        macro_refresh_seconds=args.macro_refresh_seconds,
        top_n=args.top_n,
    )

    results = search(request)
    if not results:
        parser.error("No valid strategy configurations were evaluated – adjust the search space.")
        return 1

    print(f"Tested {len(results)} configurations. Top {request.top_n}:")
    for idx, result in enumerate(results[: request.top_n], start=1):
        print("-" * 80)
        print(f"Rank #{idx} | Score {result.score:.2f}")
        print(result.describe())

    return 0


if __name__ == "__main__":  # pragma: no cover - CLI helper
    raise SystemExit(main())

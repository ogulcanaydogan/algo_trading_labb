"""
Regime-Based Strategy Selection.

Selects and configures trading strategies based on current market regime:
- BULL: Trend-following long
- BEAR: Trend-following short or defensive flat
- CRASH: Risk-off flat or bounded short
- SIDEWAYS: Mean reversion
- HIGH_VOL: Reduced activity or flat

Each strategy generates signals that are then validated by the risk engine.
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

from .regime_detector import MarketRegime, RegimeState

logger = logging.getLogger(__name__)


class SignalDirection(Enum):
    """Signal direction."""

    LONG = "long"
    SHORT = "short"
    FLAT = "flat"


@dataclass
class StrategySignal:
    """Signal generated by a strategy."""

    direction: SignalDirection
    confidence: float  # 0.0 to 1.0
    entry_price: float
    stop_loss: float
    take_profit: Optional[float] = None
    reason: str = ""
    strategy_name: str = ""
    regime: Optional[MarketRegime] = None
    timestamp: datetime = field(default_factory=datetime.now)

    # Additional metadata
    indicators: Dict[str, float] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "direction": self.direction.value,
            "confidence": round(self.confidence, 4),
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit": self.take_profit,
            "reason": self.reason,
            "strategy_name": self.strategy_name,
            "regime": self.regime.value if self.regime else None,
            "timestamp": self.timestamp.isoformat(),
            "indicators": self.indicators,
        }

    @property
    def is_entry(self) -> bool:
        return self.direction in (SignalDirection.LONG, SignalDirection.SHORT)

    @property
    def risk_reward_ratio(self) -> float:
        if not self.take_profit or self.entry_price == 0:
            return 0
        stop_dist = abs(self.entry_price - self.stop_loss)
        tp_dist = abs(self.take_profit - self.entry_price)
        return tp_dist / stop_dist if stop_dist > 0 else 0


@dataclass
class StrategyConfig:
    """Configuration for a strategy."""

    # MA parameters
    ma_fast: int = 10
    ma_slow: int = 30

    # RSI parameters
    rsi_period: int = 14
    rsi_overbought: float = 70
    rsi_oversold: float = 30

    # Bollinger parameters
    bb_period: int = 20
    bb_std: float = 2.0

    # ATR for stops
    atr_period: int = 14
    atr_stop_multiplier: float = 2.0
    atr_tp_multiplier: float = 3.0

    # Signal thresholds
    min_confidence: float = 0.5


class RegimeStrategy(ABC):
    """Base class for regime-specific strategies."""

    def __init__(self, config: Optional[StrategyConfig] = None):
        self.config = config or StrategyConfig()
        self.name = self.__class__.__name__

    @abstractmethod
    def generate_signal(
        self,
        df: pd.DataFrame,
        regime_state: RegimeState,
    ) -> Optional[StrategySignal]:
        """Generate trading signal from data."""
        pass

    def _compute_atr(self, df: pd.DataFrame) -> np.ndarray:
        """Compute ATR."""
        high = df["high"].values
        low = df["low"].values
        close = df["close"].values

        tr1 = high - low
        tr2 = np.abs(high - np.roll(close, 1))
        tr3 = np.abs(low - np.roll(close, 1))

        tr = np.maximum(tr1, np.maximum(tr2, tr3))
        tr[0] = tr1[0]

        return pd.Series(tr).rolling(self.config.atr_period).mean().values

    def _compute_ma(self, data: np.ndarray, period: int) -> np.ndarray:
        """Compute simple moving average."""
        return pd.Series(data).rolling(period).mean().values

    def _compute_ema(self, data: np.ndarray, period: int) -> np.ndarray:
        """Compute exponential moving average."""
        return pd.Series(data).ewm(span=period).mean().values

    def _compute_rsi(self, close: np.ndarray, period: int) -> np.ndarray:
        """Compute RSI."""
        delta = np.diff(close, prepend=close[0])
        gain = np.where(delta > 0, delta, 0)
        loss = np.where(delta < 0, -delta, 0)

        avg_gain = pd.Series(gain).rolling(period).mean().values
        avg_loss = pd.Series(loss).rolling(period).mean().values

        rs = avg_gain / (avg_loss + 1e-10)
        return 100 - (100 / (1 + rs))

    def _compute_bollinger(self, close: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Compute Bollinger Bands."""
        ma = self._compute_ma(close, self.config.bb_period)
        std = pd.Series(close).rolling(self.config.bb_period).std().values
        upper = ma + self.config.bb_std * std
        lower = ma - self.config.bb_std * std
        return ma, upper, lower


class TrendFollowingStrategy(RegimeStrategy):
    """
    Trend-following strategy for BULL and BEAR regimes.

    Entry: MA crossover + trend confirmation
    Exit: Stop loss or MA cross back
    """

    def __init__(
        self,
        direction: str = "long",  # "long" or "short" or "both"
        config: Optional[StrategyConfig] = None,
    ):
        super().__init__(config)
        self.direction = direction
        self.name = f"TrendFollowing_{direction}"

    def generate_signal(
        self,
        df: pd.DataFrame,
        regime_state: RegimeState,
    ) -> Optional[StrategySignal]:
        if len(df) < self.config.ma_slow + 10:
            return None

        df = df.copy()
        df.columns = df.columns.str.lower()

        close = df["close"].values
        high = df["high"].values
        low = df["low"].values

        # Compute indicators
        ma_fast = self._compute_ema(close, self.config.ma_fast)
        ma_slow = self._compute_ema(close, self.config.ma_slow)
        atr = self._compute_atr(df)
        rsi = self._compute_rsi(close, self.config.rsi_period)

        current_price = close[-1]
        current_atr = atr[-1]

        # Check for MA crossover
        ma_diff_now = ma_fast[-1] - ma_slow[-1]
        ma_diff_prev = ma_fast[-2] - ma_slow[-2]

        bullish_cross = ma_diff_prev <= 0 and ma_diff_now > 0
        bearish_cross = ma_diff_prev >= 0 and ma_diff_now < 0

        signal = None

        # Long signal
        if self.direction in ("long", "both") and bullish_cross:
            # Confirm with RSI not overbought
            if rsi[-1] < self.config.rsi_overbought:
                stop_loss = current_price - self.config.atr_stop_multiplier * current_atr
                take_profit = current_price + self.config.atr_tp_multiplier * current_atr

                confidence = 0.5
                # Higher confidence if trend is strong
                if regime_state and regime_state.indicators.trend_strength > 30:
                    confidence += 0.2
                if rsi[-1] < 50:  # Room to run
                    confidence += 0.1

                signal = StrategySignal(
                    direction=SignalDirection.LONG,
                    confidence=min(1.0, confidence),
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    reason=f"Bullish MA cross, RSI={rsi[-1]:.0f}",
                    strategy_name=self.name,
                    regime=regime_state.regime if regime_state else None,
                    indicators={
                        "ma_fast": ma_fast[-1],
                        "ma_slow": ma_slow[-1],
                        "rsi": rsi[-1],
                        "atr": current_atr,
                    },
                )

        # Short signal
        elif self.direction in ("short", "both") and bearish_cross:
            # Confirm with RSI not oversold
            if rsi[-1] > self.config.rsi_oversold:
                stop_loss = current_price + self.config.atr_stop_multiplier * current_atr
                take_profit = current_price - self.config.atr_tp_multiplier * current_atr

                confidence = 0.5
                if regime_state and regime_state.indicators.trend_strength > 30:
                    confidence += 0.2
                if rsi[-1] > 50:
                    confidence += 0.1

                signal = StrategySignal(
                    direction=SignalDirection.SHORT,
                    confidence=min(1.0, confidence),
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    reason=f"Bearish MA cross, RSI={rsi[-1]:.0f}",
                    strategy_name=self.name,
                    regime=regime_state.regime if regime_state else None,
                    indicators={
                        "ma_fast": ma_fast[-1],
                        "ma_slow": ma_slow[-1],
                        "rsi": rsi[-1],
                        "atr": current_atr,
                    },
                )

        return signal


class MeanReversionStrategy(RegimeStrategy):
    """
    Mean reversion strategy for SIDEWAYS regime.

    Entry: Price touches Bollinger Band + RSI confirmation
    Exit: Price returns to middle band or opposite band
    """

    def __init__(self, config: Optional[StrategyConfig] = None):
        super().__init__(config)
        self.name = "MeanReversion"

    def generate_signal(
        self,
        df: pd.DataFrame,
        regime_state: RegimeState,
    ) -> Optional[StrategySignal]:
        if len(df) < self.config.bb_period + 10:
            return None

        df = df.copy()
        df.columns = df.columns.str.lower()

        close = df["close"].values

        # Compute indicators
        bb_ma, bb_upper, bb_lower = self._compute_bollinger(close)
        rsi = self._compute_rsi(close, self.config.rsi_period)
        atr = self._compute_atr(df)

        current_price = close[-1]
        current_atr = atr[-1]

        signal = None

        # Long at lower band
        if current_price <= bb_lower[-1] and rsi[-1] < self.config.rsi_oversold:
            stop_loss = current_price - self.config.atr_stop_multiplier * current_atr
            take_profit = bb_ma[-1]  # Target middle band

            confidence = 0.5
            # Higher confidence if very oversold
            if rsi[-1] < 25:
                confidence += 0.2
            if regime_state and regime_state.indicators.range_bound_score > 0.7:
                confidence += 0.1

            signal = StrategySignal(
                direction=SignalDirection.LONG,
                confidence=min(1.0, confidence),
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reason=f"Price at lower BB, RSI={rsi[-1]:.0f} (oversold)",
                strategy_name=self.name,
                regime=regime_state.regime if regime_state else None,
                indicators={
                    "bb_lower": bb_lower[-1],
                    "bb_ma": bb_ma[-1],
                    "bb_upper": bb_upper[-1],
                    "rsi": rsi[-1],
                },
            )

        # Short at upper band
        elif current_price >= bb_upper[-1] and rsi[-1] > self.config.rsi_overbought:
            stop_loss = current_price + self.config.atr_stop_multiplier * current_atr
            take_profit = bb_ma[-1]

            confidence = 0.5
            if rsi[-1] > 75:
                confidence += 0.2
            if regime_state and regime_state.indicators.range_bound_score > 0.7:
                confidence += 0.1

            signal = StrategySignal(
                direction=SignalDirection.SHORT,
                confidence=min(1.0, confidence),
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reason=f"Price at upper BB, RSI={rsi[-1]:.0f} (overbought)",
                strategy_name=self.name,
                regime=regime_state.regime if regime_state else None,
                indicators={
                    "bb_lower": bb_lower[-1],
                    "bb_ma": bb_ma[-1],
                    "bb_upper": bb_upper[-1],
                    "rsi": rsi[-1],
                },
            )

        return signal


class DefensiveStrategy(RegimeStrategy):
    """
    Defensive strategy for CRASH and HIGH_VOL regimes.

    Primarily stays flat. May take bounded short positions with tight stops.
    """

    def __init__(
        self,
        allow_short: bool = False,
        config: Optional[StrategyConfig] = None,
    ):
        super().__init__(config)
        self.allow_short = allow_short
        self.name = "Defensive"

    def generate_signal(
        self,
        df: pd.DataFrame,
        regime_state: RegimeState,
    ) -> Optional[StrategySignal]:
        # Default: stay flat
        if not self.allow_short:
            return StrategySignal(
                direction=SignalDirection.FLAT,
                confidence=1.0,
                entry_price=df["close"].iloc[-1] if len(df) > 0 else 0,
                stop_loss=0,
                reason="Defensive mode - staying flat",
                strategy_name=self.name,
                regime=regime_state.regime if regime_state else None,
            )

        # Allow bounded short in extreme conditions
        if len(df) < 20:
            return None

        df = df.copy()
        df.columns = df.columns.str.lower()

        close = df["close"].values
        atr = self._compute_atr(df)
        rsi = self._compute_rsi(close, self.config.rsi_period)

        current_price = close[-1]
        current_atr = atr[-1]

        # Short conditions for different regimes
        regime_name = (
            regime_state.regime.value if regime_state and regime_state.regime else "unknown"
        )

        # Strong bear / crash: short on overbought bounces (RSI > 60)
        # High vol: short only on extreme overbought (RSI > 75)
        rsi_threshold = 60 if regime_name in ("crash", "strong_bear", "bear") else 75

        if regime_state and rsi[-1] > rsi_threshold:
            # Calculate confidence based on RSI extremity
            confidence = min(0.75, 0.4 + (rsi[-1] - rsi_threshold) / 100)

            # Tighter stops in high volatility
            stop_multiplier = 1.0 if regime_name == "high_vol" else 1.5
            target_multiplier = 1.5 if regime_name == "high_vol" else 2.0

            stop_loss = current_price + current_atr * stop_multiplier
            take_profit = current_price - current_atr * target_multiplier

            return StrategySignal(
                direction=SignalDirection.SHORT,
                confidence=confidence,
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                reason=f"Defensive short, RSI={rsi[-1]:.0f} > {rsi_threshold} in {regime_name}",
                strategy_name=self.name,
                regime=regime_state.regime,
                indicators={"rsi": rsi[-1], "atr": current_atr, "rsi_threshold": rsi_threshold},
            )

        # Default flat
        return StrategySignal(
            direction=SignalDirection.FLAT,
            confidence=1.0,
            entry_price=current_price,
            stop_loss=0,
            reason="Defensive mode - conditions not met for short",
            strategy_name=self.name,
            regime=regime_state.regime if regime_state else None,
        )


class RegimeStrategySelector:
    """
    Selects appropriate strategy based on current regime.

    Maps regimes to strategies and manages strategy lifecycle.
    Respects user risk settings from control file.
    """

    def __init__(
        self,
        config: Optional[StrategyConfig] = None,
        data_dir: Optional[str] = None,
    ):
        self.config = config or StrategyConfig()
        self.data_dir = data_dir

        # Risk settings from control file
        self._allow_shorting = False
        self._allow_leverage = False
        self._aggressive_mode = False

        # Load risk settings if data_dir is provided
        if self.data_dir:
            self._load_risk_settings()

        # Initialize strategies based on current risk settings
        self._init_strategies()

        self._current_strategy: Optional[RegimeStrategy] = None
        self._signal_history: List[StrategySignal] = []

    def _load_risk_settings(self) -> None:
        """Load risk settings from control file."""
        import json
        from pathlib import Path

        try:
            control_file = Path(self.data_dir) / "control.json"
            if control_file.exists():
                with open(control_file) as f:
                    control = json.load(f)
                    self._allow_shorting = control.get("allow_shorting", False)
                    self._allow_leverage = control.get("allow_leverage", False)
                    self._aggressive_mode = control.get("aggressive_mode", False)
                    logger.debug(
                        f"Loaded risk settings: shorting={self._allow_shorting}, "
                        f"leverage={self._allow_leverage}, aggressive={self._aggressive_mode}"
                    )
        except Exception as e:
            logger.warning(f"Could not load risk settings: {e}")

    def _init_strategies(self) -> None:
        """Initialize strategies based on current risk settings."""
        # Determine if shorting is allowed based on user settings
        allow_short = self._allow_shorting

        # Initialize strategies for each regime
        self.strategies: Dict[MarketRegime, RegimeStrategy] = {
            # Bullish regimes - go long
            MarketRegime.STRONG_BULL: TrendFollowingStrategy("long", self.config),
            MarketRegime.BULL: TrendFollowingStrategy("long", self.config),
            # Bearish regimes - short ONLY if user enabled shorting
            MarketRegime.BEAR: TrendFollowingStrategy(
                "short" if allow_short else "flat", self.config
            ),
            MarketRegime.STRONG_BEAR: TrendFollowingStrategy(
                "short" if allow_short else "flat", self.config
            ),
            # Crisis regimes - defensive with shorting based on user setting
            MarketRegime.CRASH: DefensiveStrategy(allow_short=allow_short, config=self.config),
            MarketRegime.HIGH_VOL: DefensiveStrategy(allow_short=allow_short, config=self.config),
            MarketRegime.VOLATILE: DefensiveStrategy(allow_short=allow_short, config=self.config),
            # Range-bound - mean reversion (no shorting)
            MarketRegime.SIDEWAYS: MeanReversionStrategy(self.config),
            # Unknown - stay safe (no shorting)
            MarketRegime.UNKNOWN: DefensiveStrategy(allow_short=False, config=self.config),
        }

        logger.info(f"Strategies initialized: shorting={'enabled' if allow_short else 'disabled'}")

    def reload_risk_settings(self) -> None:
        """Reload risk settings from control file and re-initialize strategies."""
        if self.data_dir:
            self._load_risk_settings()
            self._init_strategies()
            logger.info("Risk settings reloaded")

    def get_strategy(self, regime: MarketRegime) -> RegimeStrategy:
        """Get strategy for a specific regime."""
        return self.strategies.get(regime, self.strategies[MarketRegime.UNKNOWN])

    @property
    def risk_settings(self) -> Dict[str, bool]:
        """Get current risk settings."""
        return {
            "shorting": self._allow_shorting,
            "leverage": self._allow_leverage,
            "aggressive": self._aggressive_mode,
        }

    def generate_signal(
        self,
        df: pd.DataFrame,
        regime_state: RegimeState,
        reload_settings: bool = False,
    ) -> Optional[StrategySignal]:
        """
        Generate signal using regime-appropriate strategy.

        Args:
            df: OHLCV DataFrame
            regime_state: Current regime state
            reload_settings: If True, reload risk settings before generating signal

        Returns:
            StrategySignal or None if no signal
        """
        # Optionally reload risk settings (e.g., every few minutes)
        if reload_settings:
            self.reload_risk_settings()

        regime = regime_state.regime if regime_state else MarketRegime.UNKNOWN
        strategy = self.get_strategy(regime)
        self._current_strategy = strategy

        signal = strategy.generate_signal(df, regime_state)

        if signal and signal.is_entry:
            # Apply minimum confidence filter
            if signal.confidence < self.config.min_confidence:
                logger.debug(
                    f"Signal filtered: confidence {signal.confidence:.2f} < {self.config.min_confidence}"
                )
                return None

            self._signal_history.append(signal)
            if len(self._signal_history) > 500:
                self._signal_history = self._signal_history[-250:]

            logger.info(
                f"Signal generated: {signal.direction.value} | "
                f"strategy={strategy.name} | regime={regime.value} | "
                f"confidence={signal.confidence:.2f}"
            )

        return signal

    def set_strategy(self, regime: MarketRegime, strategy: RegimeStrategy) -> None:
        """Override strategy for a specific regime."""
        self.strategies[regime] = strategy
        logger.info(f"Strategy override: {regime.value} -> {strategy.name}")

    def get_signal_stats(self) -> Dict[str, Any]:
        """Get statistics about generated signals."""
        if not self._signal_history:
            return {}

        directions = {}
        strategies = {}
        regimes = {}

        for sig in self._signal_history:
            d = sig.direction.value
            directions[d] = directions.get(d, 0) + 1

            s = sig.strategy_name
            strategies[s] = strategies.get(s, 0) + 1

            r = sig.regime.value if sig.regime else "unknown"
            regimes[r] = regimes.get(r, 0) + 1

        total = len(self._signal_history)

        return {
            "total_signals": total,
            "direction_distribution": {k: round(v / total * 100, 1) for k, v in directions.items()},
            "strategy_distribution": {k: round(v / total * 100, 1) for k, v in strategies.items()},
            "regime_distribution": {k: round(v / total * 100, 1) for k, v in regimes.items()},
            "avg_confidence": round(sum(s.confidence for s in self._signal_history) / total, 3),
        }

    @property
    def current_strategy(self) -> Optional[RegimeStrategy]:
        return self._current_strategy

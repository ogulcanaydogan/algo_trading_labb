#!/usr/bin/env python3
"""
Daily Shadow Health Check.

Phase 2B Operational Script.
Runs lightweight daily checks to ensure shadow data collection is healthy.

Checks:
1. Shadow logging working (no missing rows)
2. Number of decisions collected
3. Capital preservation state transitions
4. Strategy weighting shifts (verify clamp not exceeded)
5. TradeGate rejection distribution

Output: data/reports/daily_shadow_health_YYYY-MM-DD.json

CRITICAL: This is monitoring only. No execution authority.
"""

import json
import logging
import sys
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from pathlib import Path
from typing import Any, Dict, List, Optional

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from bot.rl.shadow_data_collector import (
    ShadowCollectorConfig,
    ShadowDataCollector,
    get_shadow_collector,
    read_paper_live_heartbeat,
    is_heartbeat_recent,
    HEARTBEAT_PATH,
)
from bot.rl.strategy_weighting_advisor import (
    MAX_DAILY_WEIGHT_SHIFT,
    get_strategy_weighting_advisor,
)

# Turnover governor import (optional - may not be available)
try:
    from bot.turnover_governor import get_turnover_governor, TurnoverGovernor
    TURNOVER_GOVERNOR_AVAILABLE = True
except ImportError:
    TURNOVER_GOVERNOR_AVAILABLE = False

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)s | %(name)s | %(message)s",
)
logger = logging.getLogger(__name__)


# Data mode constants
DATA_MODE_TEST = "TEST"
DATA_MODE_PAPER_LIVE = "PAPER_LIVE"

# Alert severity levels
ALERT_SEVERITY_HIGH = "HIGH"
ALERT_SEVERITY_MEDIUM = "MEDIUM"
ALERT_SEVERITY_LOW = "LOW"

# Heartbeat constants
HEARTBEAT_MAX_AGE_HOURS = 2.0


@dataclass
class Alert:
    """Structured alert with severity."""
    severity: str
    message: str

    def to_dict(self) -> Dict[str, Any]:
        return {"severity": self.severity, "message": self.message}

    def __str__(self) -> str:
        return f"[{self.severity}] {self.message}"


@dataclass
class DailyHealthReport:
    """Daily shadow health report."""
    date: str
    timestamp: str

    # Data mode: TEST (generated by scripts) or PAPER_LIVE (from live paper trading)
    # Determined by checking the data_mode field in shadow decisions
    data_mode: str = DATA_MODE_TEST  # Default to TEST for safety
    decisions_by_mode: Dict[str, int] = field(default_factory=dict)

    # Heartbeat verification
    heartbeat_found: bool = False
    heartbeat_recent: bool = False
    heartbeat_age_hours: float = 0.0
    heartbeat_pid: Optional[int] = None
    heartbeat_symbols: List[str] = field(default_factory=list)

    # Shadow collection status
    shadow_logging_healthy: bool = False
    decisions_collected_today: int = 0
    pending_decisions: int = 0
    total_decisions_all_time: int = 0

    # Capital preservation
    preservation_level: str = "unknown"
    preservation_transitions_today: int = 0
    preservation_alert: bool = False
    preservation_alert_reason: str = ""

    # Strategy weighting
    weighting_enabled: bool = False
    weight_shifts_today: int = 0
    max_shift_observed: float = 0.0
    clamp_exceeded: bool = False
    clamp_violation_details: str = ""

    # TradeGate rejections
    tradegate_rejections_today: int = 0
    rejection_reasons: Dict[str, int] = field(default_factory=dict)
    rejection_distribution_alert: bool = False

    # Turnover Governor (friction reduction)
    turnover_decisions_blocked: int = 0
    turnover_blocked_by_interval: int = 0
    turnover_blocked_by_daily_limit: int = 0
    turnover_blocked_by_ev_cost: int = 0
    turnover_cost_drag_avoided: float = 0.0
    turnover_per_symbol_configs: Dict[str, Dict[str, Any]] = field(default_factory=dict)
    turnover_per_symbol_blocked: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    # Summary
    overall_health: str = "HEALTHY"
    alerts: List[Alert] = field(default_factory=list)
    recommendations: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "date": self.date,
            "timestamp": self.timestamp,
            "data_mode": self.data_mode,
            "heartbeat": {
                "found": self.heartbeat_found,
                "recent": self.heartbeat_recent,
                "age_hours": round(self.heartbeat_age_hours, 2),
                "pid": self.heartbeat_pid,
                "symbols": self.heartbeat_symbols,
            },
            "shadow_collection": {
                "logging_healthy": self.shadow_logging_healthy,
                "decisions_today": self.decisions_collected_today,
                "decisions_by_mode": self.decisions_by_mode,
                "pending_decisions": self.pending_decisions,
                "total_all_time": self.total_decisions_all_time,
            },
            "capital_preservation": {
                "current_level": self.preservation_level,
                "transitions_today": self.preservation_transitions_today,
                "alert": self.preservation_alert,
                "alert_reason": self.preservation_alert_reason,
            },
            "strategy_weighting": {
                "enabled": self.weighting_enabled,
                "shifts_today": self.weight_shifts_today,
                "max_shift_observed": round(self.max_shift_observed, 4),
                "clamp_exceeded": self.clamp_exceeded,
                "clamp_violation_details": self.clamp_violation_details,
                "max_allowed_shift": MAX_DAILY_WEIGHT_SHIFT,
            },
            "tradegate": {
                "rejections_today": self.tradegate_rejections_today,
                "rejection_reasons": self.rejection_reasons,
                "distribution_alert": self.rejection_distribution_alert,
            },
            "turnover_governor": {
                "decisions_blocked": self.turnover_decisions_blocked,
                "blocked_by_interval": self.turnover_blocked_by_interval,
                "blocked_by_daily_limit": self.turnover_blocked_by_daily_limit,
                "blocked_by_ev_cost": self.turnover_blocked_by_ev_cost,
                "cost_drag_avoided": round(self.turnover_cost_drag_avoided, 2),
                "per_symbol_configs": self.turnover_per_symbol_configs,
                "per_symbol_blocked": self.turnover_per_symbol_blocked,
            },
            "summary": {
                "overall_health": self.overall_health,
                "alerts": [a.to_dict() for a in self.alerts],
                "recommendations": self.recommendations,
            },
        }


class DailyShadowHealthChecker:
    """Daily health checker for shadow data collection."""

    def __init__(
        self,
        report_dir: Path = Path("data/reports"),
        shadow_log_path: Path = Path("data/rl/shadow_decisions.jsonl"),
        preservation_state_path: Path = Path("data/capital_preservation_state.json"),
        weighting_state_path: Path = Path("data/rl/strategy_weights.json"),
    ):
        self.report_dir = report_dir
        self.report_dir.mkdir(parents=True, exist_ok=True)
        self.shadow_log_path = shadow_log_path
        self.preservation_state_path = preservation_state_path
        self.weighting_state_path = weighting_state_path

    def run_health_check(self) -> DailyHealthReport:
        """Run all daily health checks."""
        today = datetime.now().strftime("%Y-%m-%d")
        report = DailyHealthReport(
            date=today,
            timestamp=datetime.now().isoformat(),
        )

        # Check shadow logging
        self._check_shadow_logging(report)

        # Check paper-live heartbeat
        self._check_heartbeat(report)

        # Check capital preservation
        self._check_capital_preservation(report)

        # Check strategy weighting
        self._check_strategy_weighting(report)

        # Check TradeGate (from shadow log if available)
        self._check_tradegate_rejections(report)

        # Check turnover governor
        self._check_turnover_governor(report)

        # Determine overall health
        self._determine_overall_health(report)

        return report

    def _check_shadow_logging(self, report: DailyHealthReport):
        """Check shadow logging health."""
        try:
            collector = get_shadow_collector()
            stats = collector.get_collection_stats()

            report.shadow_logging_healthy = True
            report.total_decisions_all_time = stats.get("total_decisions", 0)
            report.pending_decisions = stats.get("pending_decisions", 0)

            # Count today's decisions from log file and track data_mode
            today = datetime.now().strftime("%Y-%m-%d")
            mode_counts = {DATA_MODE_TEST: 0, DATA_MODE_PAPER_LIVE: 0}

            if self.shadow_log_path.exists():
                with open(self.shadow_log_path) as f:
                    for line in f:
                        try:
                            entry = json.loads(line)
                            if entry.get("timestamp", "").startswith(today):
                                report.decisions_collected_today += 1
                                # Track data_mode (default to TEST if missing for backwards compat)
                                mode = entry.get("data_mode", DATA_MODE_TEST)
                                mode_counts[mode] = mode_counts.get(mode, 0) + 1
                        except json.JSONDecodeError:
                            continue

            report.decisions_by_mode = mode_counts

            # Determine overall data_mode for the day
            # Priority: PAPER_LIVE if any exist, otherwise TEST
            if mode_counts.get(DATA_MODE_PAPER_LIVE, 0) > 0:
                report.data_mode = DATA_MODE_PAPER_LIVE
            elif mode_counts.get(DATA_MODE_TEST, 0) > 0:
                report.data_mode = DATA_MODE_TEST
            else:
                report.data_mode = DATA_MODE_TEST  # Default for empty

            # Alert if only TEST data collected
            if report.decisions_collected_today > 0 and report.data_mode == DATA_MODE_TEST:
                report.alerts.append(Alert(
                    severity=ALERT_SEVERITY_LOW,
                    message=f"All {report.decisions_collected_today} decisions are TEST data - "
                            "not counted for Phase 2C promotion"
                ))
                report.recommendations.append(
                    "Start paper trading with shadow mode enabled to collect PAPER_LIVE data"
                )

            # Alert if no decisions collected during trading hours
            hour = datetime.now().hour
            if 9 <= hour <= 17 and report.decisions_collected_today == 0:
                report.alerts.append(Alert(
                    severity=ALERT_SEVERITY_MEDIUM,
                    message="No decisions collected today during trading hours"
                ))
                report.recommendations.append("Verify paper trading is running with shadow mode enabled")

        except Exception as e:
            report.shadow_logging_healthy = False
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_HIGH,
                message=f"Shadow logging check failed: {e}"
            ))

    def _check_capital_preservation(self, report: DailyHealthReport):
        """Check capital preservation state."""
        try:
            if self.preservation_state_path.exists():
                with open(self.preservation_state_path) as f:
                    state = json.load(f)

                report.preservation_level = state.get("level", "unknown")

                # Check for lockdown
                if report.preservation_level == "lockdown":
                    report.preservation_alert = True
                    reasons = state.get("trigger_reasons", [])
                    report.preservation_alert_reason = "; ".join(reasons) if reasons else "Lockdown active"
                    report.alerts.append(Alert(
                        severity=ALERT_SEVERITY_HIGH,
                        message=f"Capital preservation in LOCKDOWN: {report.preservation_alert_reason}"
                    ))

                # Check for frequent transitions (would need history tracking)
                # For now, just check current state
                if report.preservation_level in ["elevated", "lockdown"]:
                    report.recommendations.append(
                        f"Capital preservation at {report.preservation_level} - review recent losses"
                    )

        except Exception as e:
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_MEDIUM,
                message=f"Capital preservation check failed: {e}"
            ))

    def _check_strategy_weighting(self, report: DailyHealthReport):
        """Check strategy weighting advisor state."""
        try:
            advisor = get_strategy_weighting_advisor()
            status = advisor.get_advisor_status()

            report.weighting_enabled = status.get("enabled", False)
            report.weight_shifts_today = status.get("updates_today", 0)

            # Check weight change analysis
            analysis = advisor.get_weight_change_analysis()
            if "cumulative_change" in analysis:
                for strategy, change in analysis["cumulative_change"].items():
                    abs_change = abs(change)
                    if abs_change > report.max_shift_observed:
                        report.max_shift_observed = abs_change

                    # CRITICAL: Check if clamp was exceeded
                    if abs_change > MAX_DAILY_WEIGHT_SHIFT:
                        report.clamp_exceeded = True
                        report.clamp_violation_details = (
                            f"Strategy {strategy} shifted {abs_change:.2%}, "
                            f"exceeds max {MAX_DAILY_WEIGHT_SHIFT:.2%}"
                        )
                        report.alerts.append(Alert(
                            severity=ALERT_SEVERITY_HIGH,
                            message=f"CLAMP VIOLATION: {report.clamp_violation_details}"
                        ))

        except Exception as e:
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_MEDIUM,
                message=f"Strategy weighting check failed: {e}"
            ))

    def _check_tradegate_rejections(self, report: DailyHealthReport):
        """Check TradeGate rejection distribution."""
        try:
            today = datetime.now().strftime("%Y-%m-%d")

            if self.shadow_log_path.exists():
                with open(self.shadow_log_path) as f:
                    for line in f:
                        try:
                            entry = json.loads(line)
                            if not entry.get("timestamp", "").startswith(today):
                                continue

                            gate_decision = entry.get("gate_decision", {})
                            if not gate_decision.get("approved", True):
                                report.tradegate_rejections_today += 1
                                reason = gate_decision.get("rejection_reason", "unknown")
                                report.rejection_reasons[reason] = (
                                    report.rejection_reasons.get(reason, 0) + 1
                                )
                        except json.JSONDecodeError:
                            continue

            # Alert if rejection rate is high
            total_decisions = report.decisions_collected_today
            if total_decisions > 0:
                rejection_rate = report.tradegate_rejections_today / total_decisions
                if rejection_rate > 0.8:  # 80% rejection rate
                    report.rejection_distribution_alert = True
                    report.alerts.append(Alert(
                        severity=ALERT_SEVERITY_MEDIUM,
                        message=f"High TradeGate rejection rate: {rejection_rate:.1%}"
                    ))
                    report.recommendations.append(
                        "Review TradeGate thresholds or signal quality"
                    )

        except Exception as e:
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_MEDIUM,
                message=f"TradeGate rejection check failed: {e}"
            ))

    def _check_turnover_governor(self, report: DailyHealthReport):
        """Check turnover governor statistics for friction reduction tracking."""
        if not TURNOVER_GOVERNOR_AVAILABLE:
            return

        try:
            governor = get_turnover_governor()
            stats = governor.get_daily_stats()

            report.turnover_decisions_blocked = stats.get("total_decisions_blocked", 0)
            report.turnover_blocked_by_interval = stats.get("blocked_by_interval", 0)
            report.turnover_blocked_by_daily_limit = stats.get("blocked_by_daily_limit", 0)
            report.turnover_blocked_by_ev_cost = stats.get("blocked_by_ev_cost", 0)
            report.turnover_cost_drag_avoided = stats.get("total_cost_drag_avoided", 0.0)

            # Get per-symbol configs and blocked stats
            all_configs = governor.get_all_symbol_configs()
            report.turnover_per_symbol_configs = all_configs.get("symbols", {})

            # Also include override patterns for reference
            if all_configs.get("override_patterns"):
                report.turnover_per_symbol_configs["_override_patterns"] = all_configs["override_patterns"]
                report.turnover_per_symbol_configs["_default_config"] = all_configs["default_config"]

            # Get per-symbol blocked stats
            weekly_stats = governor.get_weekly_stats()
            report.turnover_per_symbol_blocked = weekly_stats.get("by_symbol", {})

            # Add informational note if significant cost drag was avoided
            if report.turnover_cost_drag_avoided >= 10.0:
                report.recommendations.append(
                    f"Turnover governor avoided ${report.turnover_cost_drag_avoided:.2f} in estimated trading costs today"
                )

        except Exception as e:
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_LOW,
                message=f"Turnover governor check failed: {e}"
            ))

    def _check_heartbeat(self, report: DailyHealthReport):
        """Check paper-live heartbeat for shadow collector attachment verification."""
        try:
            heartbeat = read_paper_live_heartbeat()

            if heartbeat is None:
                # No heartbeat file found
                report.heartbeat_found = False
                report.heartbeat_recent = False
                report.alerts.append(Alert(
                    severity=ALERT_SEVERITY_MEDIUM,
                    message="No paper-live heartbeat found - paper trading may not be running "
                            "or shadow collector not attached"
                ))
                report.recommendations.append(
                    "Start paper trading with shadow mode enabled to begin PAPER_LIVE data collection"
                )
                return

            # Heartbeat file exists
            report.heartbeat_found = True
            report.heartbeat_pid = heartbeat.get("pid")
            report.heartbeat_symbols = heartbeat.get("symbols", [])

            # Check if heartbeat is recent
            if is_heartbeat_recent(heartbeat, max_age_hours=HEARTBEAT_MAX_AGE_HOURS):
                report.heartbeat_recent = True

                # Calculate age for reporting
                heartbeat_ts = datetime.fromisoformat(heartbeat.get("timestamp", ""))
                age = datetime.now() - heartbeat_ts
                report.heartbeat_age_hours = age.total_seconds() / 3600

                # CRITICAL CHECK: Heartbeat recent but no PAPER_LIVE decisions
                paper_live_count = report.decisions_by_mode.get(DATA_MODE_PAPER_LIVE, 0)
                if paper_live_count == 0:
                    report.alerts.append(Alert(
                        severity=ALERT_SEVERITY_HIGH,
                        message="Paper-live bot running (heartbeat recent) but shadow collector "
                                "not producing PAPER_LIVE decisions - check shadow_collector_attached flag"
                    ))
                    report.recommendations.append(
                        "Verify shadow collector is properly integrated with paper trading engine"
                    )
            else:
                # Heartbeat exists but is stale
                report.heartbeat_recent = False
                heartbeat_ts_str = heartbeat.get("timestamp", "unknown")
                try:
                    heartbeat_ts = datetime.fromisoformat(heartbeat_ts_str)
                    age = datetime.now() - heartbeat_ts
                    report.heartbeat_age_hours = age.total_seconds() / 3600
                except (ValueError, TypeError):
                    report.heartbeat_age_hours = float('inf')

                report.alerts.append(Alert(
                    severity=ALERT_SEVERITY_LOW,
                    message=f"Paper-live heartbeat is stale (age: {report.heartbeat_age_hours:.1f}h) - "
                            "paper trading may have stopped"
                ))

        except Exception as e:
            report.alerts.append(Alert(
                severity=ALERT_SEVERITY_MEDIUM,
                message=f"Heartbeat check failed: {e}"
            ))

    def _determine_overall_health(self, report: DailyHealthReport):
        """Determine overall health status."""
        # Count alerts by severity
        high_alerts = sum(1 for a in report.alerts if isinstance(a, Alert) and a.severity == ALERT_SEVERITY_HIGH)
        medium_alerts = sum(1 for a in report.alerts if isinstance(a, Alert) and a.severity == ALERT_SEVERITY_MEDIUM)

        if report.clamp_exceeded:
            report.overall_health = "CRITICAL"
        elif high_alerts > 0:
            report.overall_health = "WARNING"
        elif report.preservation_level == "lockdown":
            report.overall_health = "WARNING"
        elif not report.shadow_logging_healthy:
            report.overall_health = "WARNING"
        elif medium_alerts > 1:
            report.overall_health = "WARNING"
        elif len(report.alerts) > 3:
            report.overall_health = "WARNING"
        else:
            report.overall_health = "HEALTHY"

    def save_report(self, report: DailyHealthReport) -> Path:
        """Save daily health report."""
        filename = f"daily_shadow_health_{report.date}.json"
        path = self.report_dir / filename

        with open(path, "w") as f:
            json.dump(report.to_dict(), f, indent=2)

        logger.info(f"Daily health report saved: {path}")
        return path


def main():
    """Run daily shadow health check."""
    logger.info("=" * 60)
    logger.info("Daily Shadow Health Check")
    logger.info("=" * 60)

    checker = DailyShadowHealthChecker()
    report = checker.run_health_check()

    # Save report
    path = checker.save_report(report)

    # Print summary
    print("\n" + "=" * 60)
    print(f"DAILY SHADOW HEALTH CHECK - {report.date}")
    print("=" * 60)
    print(f"\nOverall Health: {report.overall_health}")
    print(f"\nShadow Collection:")
    print(f"  - Logging healthy: {report.shadow_logging_healthy}")
    print(f"  - Decisions today: {report.decisions_collected_today}")
    print(f"  - Data mode: {report.data_mode}")
    if report.decisions_by_mode:
        print(f"  - By mode: TEST={report.decisions_by_mode.get('TEST', 0)}, PAPER_LIVE={report.decisions_by_mode.get('PAPER_LIVE', 0)}")
    print(f"  - Total all time: {report.total_decisions_all_time}")

    print(f"\nPaper-Live Heartbeat:")
    print(f"  - Found: {report.heartbeat_found}")
    print(f"  - Recent: {report.heartbeat_recent}")
    if report.heartbeat_found:
        print(f"  - Age: {report.heartbeat_age_hours:.1f} hours")
        print(f"  - PID: {report.heartbeat_pid}")
        if report.heartbeat_symbols:
            print(f"  - Symbols: {', '.join(report.heartbeat_symbols)}")

    print(f"\nCapital Preservation:")
    print(f"  - Current level: {report.preservation_level}")
    if report.preservation_alert:
        print(f"  - ALERT: {report.preservation_alert_reason}")

    print(f"\nStrategy Weighting:")
    print(f"  - Enabled: {report.weighting_enabled}")
    print(f"  - Max shift observed: {report.max_shift_observed:.2%}")
    print(f"  - Clamp exceeded: {report.clamp_exceeded}")
    if report.clamp_exceeded:
        print(f"  - VIOLATION: {report.clamp_violation_details}")

    print(f"\nTradeGate:")
    print(f"  - Rejections today: {report.tradegate_rejections_today}")

    print(f"\nTurnover Governor (friction reduction):")
    print(f"  - Decisions blocked: {report.turnover_decisions_blocked}")
    if report.turnover_decisions_blocked > 0:
        print(f"    - By interval: {report.turnover_blocked_by_interval}")
        print(f"    - By daily limit: {report.turnover_blocked_by_daily_limit}")
        print(f"    - By EV/cost ratio: {report.turnover_blocked_by_ev_cost}")
        print(f"  - Cost drag avoided: ${report.turnover_cost_drag_avoided:.2f}")

    # Show per-symbol configs (excluding internal keys)
    symbol_configs = {k: v for k, v in report.turnover_per_symbol_configs.items() if not k.startswith("_")}
    if symbol_configs:
        print(f"  - Per-symbol configs:")
        for symbol, cfg in sorted(symbol_configs.items()):
            has_override = cfg.get("has_override", False)
            override_tag = " [OVERRIDE]" if has_override else ""
            print(f"    {symbol}{override_tag}: interval={cfg.get('min_interval_minutes')}min, "
                  f"max_daily={cfg.get('max_decisions_per_day')}, ev_multiple={cfg.get('min_ev_cost_multiple')}x")

    # Show per-symbol blocked stats
    if report.turnover_per_symbol_blocked:
        symbols_with_blocks = {k: v for k, v in report.turnover_per_symbol_blocked.items() if v.get("blocked", 0) > 0}
        if symbols_with_blocks:
            print(f"  - Per-symbol blocked:")
            for symbol, stats in sorted(symbols_with_blocks.items()):
                reasons = stats.get("reasons", {})
                reason_str = ", ".join(f"{k}={v}" for k, v in reasons.items())
                print(f"    {symbol}: blocked={stats.get('blocked', 0)} ({reason_str})")

    if report.alerts:
        # Group alerts by severity
        high_alerts = [a for a in report.alerts if isinstance(a, Alert) and a.severity == ALERT_SEVERITY_HIGH]
        medium_alerts = [a for a in report.alerts if isinstance(a, Alert) and a.severity == ALERT_SEVERITY_MEDIUM]
        low_alerts = [a for a in report.alerts if isinstance(a, Alert) and a.severity == ALERT_SEVERITY_LOW]

        print(f"\n‚ö†Ô∏è  ALERTS ({len(report.alerts)}):")
        if high_alerts:
            print("  [HIGH]")
            for alert in high_alerts:
                print(f"    - {alert.message}")
        if medium_alerts:
            print("  [MEDIUM]")
            for alert in medium_alerts:
                print(f"    - {alert.message}")
        if low_alerts:
            print("  [LOW]")
            for alert in low_alerts:
                print(f"    - {alert.message}")

    if report.recommendations:
        print(f"\nüí° RECOMMENDATIONS:")
        for rec in report.recommendations:
            print(f"  - {rec}")

    print(f"\nReport saved: {path}")
    print("=" * 60)

    # Exit with appropriate code
    if report.overall_health == "CRITICAL":
        sys.exit(2)
    elif report.overall_health == "WARNING":
        sys.exit(1)
    else:
        sys.exit(0)


if __name__ == "__main__":
    main()

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Algo Trading Lab Dashboard</title>
    <style>
      :root {
        color-scheme: dark;
        font-family: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
        background-color: #020617;
        color: #f8fafc;
      }
      body {
        margin: 0 auto;
        padding: 2rem;
        max-width: 1080px;
        background: radial-gradient(circle at top, rgba(30, 64, 175, 0.35), transparent 55%),
          radial-gradient(circle at bottom, rgba(14, 116, 144, 0.28), transparent 60%), #020617;
      }
      h1,
      h2 {
        font-weight: 600;
        margin: 0 0 0.5rem 0;
      }
      p {
        margin: 0;
      }
      .title-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .badge {
        display: inline-flex;
        align-items: center;
        gap: 0.35rem;
        padding: 0.35rem 0.65rem;
        border-radius: 999px;
        background: rgba(56, 189, 248, 0.18);
        color: #38bdf8;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border: 1px solid rgba(56, 189, 248, 0.35);
      }
      .hidden {
        display: none;
      }
      section {
        margin-top: 2rem;
        padding: 1.75rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.78);
        box-shadow: 0 20px 45px rgba(2, 6, 23, 0.55);
        border: 1px solid rgba(148, 163, 184, 0.18);
        backdrop-filter: blur(14px);
      }
      .timestamp {
        margin-top: 0.4rem;
        font-size: 0.9rem;
        color: #94a3b8;
      }
      .status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
        gap: 1rem;
      }
      .portfolio-status {
        margin-top: 1.5rem;
      }
      .portfolio-status-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 0.75rem;
        flex-wrap: wrap;
      }
      .portfolio-status-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1rem;
      }
      .portfolio-meta-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-top: 1.25rem;
      }
      .portfolio-summary-card {
        border-radius: 14px;
        padding: 1rem;
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(59, 130, 246, 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .portfolio-summary-card h4 {
        margin: 0;
        font-size: 0.9rem;
        color: #cbd5f5;
      }
      .summary-value {
        font-size: 1.1rem;
        font-weight: 600;
      }
      .portfolio-position-card {
        border-radius: 14px;
        padding: 1rem;
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(148, 163, 184, 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        min-height: 180px;
      }
      .portfolio-card-header {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .portfolio-card-actions {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 0.35rem;
      }
      .portfolio-card-badges {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-end;
        gap: 0.35rem;
      }
      .portfolio-symbol {
        font-size: 1.1rem;
        font-weight: 600;
      }
      .portfolio-meta {
        font-size: 0.8rem;
        color: #94a3b8;
      }
      .portfolio-position {
        font-size: 0.9rem;
        padding: 0.2rem 0.75rem;
        border-radius: 999px;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        border: 1px solid rgba(148, 163, 184, 0.3);
      }
      .portfolio-metrics {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 0.5rem;
        font-size: 0.85rem;
      }
      .portfolio-row {
        display: flex;
        flex-direction: column;
        gap: 0.2rem;
      }
      .portfolio-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #94a3b8;
      }
      .portfolio-value {
        font-size: 1rem;
        font-weight: 600;
      }
      .portfolio-note {
        font-size: 0.85rem;
        color: #cbd5f5;
      }
      .portfolio-ai {
        font-size: 0.8rem;
        color: #7dd3fc;
      }
      .portfolio-note.placeholder {
        color: #fbbf24;
      }
      .portfolio-note.paused {
        color: #f87171;
      }
      .portfolio-pause-reason {
        color: #fecaca;
      }
      .portfolio-mode {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border-radius: 999px;
        padding: 0.15rem 0.6rem;
        border: 1px solid rgba(148, 163, 184, 0.35);
      }
      .portfolio-mode.live {
        color: #f472b6;
        border-color: rgba(244, 114, 182, 0.6);
      }
      .portfolio-mode.paper {
        color: #38bdf8;
        border-color: rgba(56, 189, 248, 0.6);
      }
      .portfolio-pause-pill {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border-radius: 999px;
        padding: 0.15rem 0.6rem;
        border: 1px solid rgba(248, 113, 113, 0.7);
        color: #fecaca;
        background: rgba(127, 29, 29, 0.2);
      }
      .portfolio-guard-card ul {
        margin: 0.25rem 0 0;
        padding: 0;
        list-style: none;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .portfolio-guard-card li {
        font-size: 0.8rem;
        color: #cbd5f5;
      }
      .portfolio-toggle {
        border-radius: 999px;
        padding: 0.35rem 0.9rem;
        font-size: 0.85rem;
        font-weight: 600;
        border: 1px solid transparent;
        cursor: pointer;
        transition: opacity 0.2s ease;
      }
      .portfolio-toggle.pause {
        background: rgba(248, 113, 113, 0.15);
        border-color: rgba(248, 113, 113, 0.5);
        color: #fecaca;
      }
      .portfolio-toggle.resume {
        background: rgba(34, 197, 94, 0.15);
        border-color: rgba(34, 197, 94, 0.5);
        color: #bbf7d0;
      }
      .portfolio-toggle:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .portfolio-guard-controls {
        border-top: 1px solid rgba(148, 163, 184, 0.2);
        padding-top: 0.5rem;
        margin-top: auto;
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .portfolio-guard-hint {
        font-size: 0.75rem;
        color: #94a3b8;
        margin: 0;
      }
      .portfolio-placeholder-badge {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border-radius: 999px;
        padding: 0.15rem 0.6rem;
        border: 1px dashed rgba(251, 191, 36, 0.6);
        color: #fbbf24;
      }
      .chart-card,
      .portfolio-chart-card {
        margin-top: 1.25rem;
        padding: 1.25rem;
        border-radius: 16px;
        background: rgba(15, 23, 42, 0.92);
        border: 1px solid rgba(59, 130, 246, 0.25);
        box-shadow: 0 16px 40px rgba(2, 6, 23, 0.45);
      }
      .portfolio-chart-card {
        margin-top: 1.75rem;
      }
      .chart-card-header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.75rem;
      }
      .chart-card-header h3,
      .chart-card-header h4 {
        margin: 0;
        font-size: 1rem;
      }
      .chart-note {
        font-size: 0.8rem;
        color: #94a3b8;
      }
      .chart-canvas {
        width: 100%;
        height: 240px;
        display: block;
        margin-top: 0.75rem;
      }
      .status-card {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.85);
        border: 1px solid rgba(148, 163, 184, 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
        min-height: 110px;
      }
      .status-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: #94a3b8;
      }
      .status-value {
        font-size: 1.35rem;
        font-weight: 600;
        word-break: break-word;
      }
      .status-subtle {
        font-size: 0.8rem;
        color: #cbd5f5;
      }
      .strategy-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 1.5rem;
      }
      .strategy-card {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(30, 41, 59, 0.82);
        border: 1px solid rgba(148, 163, 184, 0.22);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .strategy-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: #94a3b8;
      }
      .strategy-value {
        font-size: 1.2rem;
        font-weight: 600;
        word-break: break-word;
      }
      .ai-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-bottom: 1.25rem;
      }
      .ai-card {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(24, 31, 50, 0.88);
        border: 1px solid rgba(56, 189, 248, 0.22);
        display: flex;
        flex-direction: column;
        gap: 0.35rem;
      }
      .ai-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #7dd3fc;
      }
      .ai-value {
        font-size: 1.35rem;
        font-weight: 600;
      }
      .ai-summary {
        margin-top: 0.75rem;
        font-size: 0.95rem;
        color: #bfdbfe;
        line-height: 1.5;
      }
      .macro-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 1rem;
        margin-bottom: 1rem;
      }
      .macro-card {
        padding: 1rem;
        border-radius: 12px;
        background: rgba(24, 24, 45, 0.9);
        border: 1px solid rgba(96, 165, 250, 0.18);
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .macro-label {
        font-size: 0.7rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #a5b4fc;
      }
      .macro-value {
        font-size: 1.3rem;
        font-weight: 600;
      }
      .macro-summary {
        font-size: 0.95rem;
        color: #cbd5f5;
        line-height: 1.55;
        margin: 0.5rem 0 1rem;
      }
      .macro-drivers {
        margin: 0.4rem 0 1rem;
        padding-left: 1.15rem;
        display: grid;
        gap: 0.3rem;
        color: #e0e7ff;
      }
      .macro-events {
        margin-top: 0.75rem;
        border: 1px solid rgba(79, 70, 229, 0.2);
        border-radius: 12px;
        background: rgba(23, 31, 64, 0.85);
        padding: 1rem;
      }
      .macro-events h3 {
        margin: 0 0 0.75rem 0;
        font-size: 1rem;
      }
      .playbook-container {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 1.25rem;
        margin-top: 1.25rem;
      }
      .playbook-highlights {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        margin: 0.75rem 0 0;
      }
      .playbook-group h3 {
        margin-top: 0;
        margin-bottom: 0.75rem;
        font-size: 1.1rem;
        color: #38bdf8;
      }
      .playbook-card {
        padding: 1.1rem;
        border-radius: 14px;
        background: rgba(13, 23, 42, 0.95);
        border: 1px solid rgba(59, 130, 246, 0.25);
        display: flex;
        flex-direction: column;
        gap: 0.65rem;
      }
      .playbook-card header {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 0.5rem;
      }
      .playbook-symbol {
        font-size: 1.15rem;
        font-weight: 600;
      }
      .playbook-horizons,
      .playbook-notes {
        margin: 0;
        padding-left: 1.2rem;
        display: flex;
        flex-direction: column;
        gap: 0.4rem;
      }
      .playbook-horizon-label {
        font-weight: 600;
        color: #e0f2fe;
      }
      .playbook-highlight {
        display: inline-block;
        padding: 0.35rem 0.6rem;
        margin: 0.25rem 0.35rem 0.25rem 0;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.16);
        border: 1px solid rgba(59, 130, 246, 0.38);
        font-size: 0.75rem;
        color: #bfdbfe;
      }
      .macro-events ul {
        margin: 0;
        padding-left: 1.1rem;
        display: grid;
        gap: 0.35rem;
      }
      .macro-events li {
        color: #e0f2fe;
        font-size: 0.92rem;
      }
      .ai-probabilities {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        margin-top: 0.5rem;
      }
      .ai-probabilities div {
        background: rgba(15, 23, 42, 0.9);
        border-radius: 10px;
        padding: 0.6rem 0.9rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
      }
      .ai-probabilities span {
        display: block;
        font-size: 0.8rem;
        color: #94a3b8;
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }
      .ai-probabilities strong {
        display: block;
        font-size: 1.05rem;
        font-weight: 600;
        color: #f8fafc;
      }
      .question-box {
        margin-top: 1.5rem;
        padding: 1.2rem;
        border-radius: 12px;
        background: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(56, 189, 248, 0.18);
        display: flex;
        flex-direction: column;
        gap: 0.75rem;
      }
      .question-box form {
        display: flex;
        flex-wrap: wrap;
        gap: 0.75rem;
        align-items: center;
      }
      .question-box input[type="text"] {
        flex: 1 1 240px;
        padding: 0.75rem 1rem;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.35);
        background: rgba(15, 23, 42, 0.92);
        color: inherit;
      }
      .question-box button {
        padding: 0.75rem 1.4rem;
        border-radius: 999px;
        border: none;
        background: linear-gradient(135deg, #38bdf8, #0ea5e9);
        color: #020617;
        font-weight: 600;
        cursor: pointer;
      }
      .question-box button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .question-answer {
        font-size: 0.95rem;
        color: #e0f2fe;
        line-height: 1.55;
      }
      .strategy-subtle {
        font-size: 0.8rem;
        color: #cbd5f5;
      }
      .strategy-rules {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
        gap: 1.25rem;
      }
      .strategy-rules h3 {
        margin-top: 0;
        font-size: 1.05rem;
      }
      .strategy-rules ul {
        margin: 0.5rem 0 0 0;
        padding-left: 1.1rem;
        display: grid;
        gap: 0.35rem;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      thead {
        background: rgba(30, 41, 59, 0.88);
      }
      th,
      td {
        padding: 0.75rem;
        text-align: left;
        border-bottom: 1px solid rgba(148, 163, 184, 0.18);
        font-size: 0.95rem;
      }
      th {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: #94a3b8;
      }
      tbody tr:hover {
        background: rgba(30, 41, 59, 0.65);
      }
      #equity-canvas {
        height: 260px;
      }
      .error {
        margin-top: 0.75rem;
        color: #f87171;
        font-size: 0.95rem;
      }
      @media (max-width: 640px) {
        body {
          padding: 1.25rem;
        }
        section {
          padding: 1.25rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="title-row">
      <h1>Algo Trading Lab Dashboard</h1>
      <span id="preview-badge" class="badge hidden">Preview</span>
    </div>
    <p class="timestamp" id="last-updated">Loading...</p>

    <section>
      <h2>Bot Status</h2>
      <div class="status-grid">
        <div class="status-card">
          <span class="status-label">Symbol</span>
          <span class="status-value" id="status-symbol">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Position</span>
          <span class="status-value" id="status-position">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Balance</span>
          <span class="status-value" id="status-balance">-</span>
          <span class="status-subtle" id="status-entry">Entry: -</span>
        </div>
        <div class="status-card">
          <span class="status-label">Unrealized PnL</span>
          <span class="status-value" id="status-pnl">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Last Signal</span>
          <span class="status-value" id="status-signal">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Signal Confidence</span>
          <span class="status-value" id="status-confidence">-</span>
        </div>
        <div class="status-card">
          <span class="status-label">Risk Per Trade</span>
          <span class="status-value" id="status-risk">-</span>
        </div>
      </div>
      <p id="status-error" class="error"></p>
      <div class="portfolio-status" id="portfolio-status-section">
        <div class="portfolio-status-header">
          <h3>Portfolio Positions</h3>
          <span class="status-subtle" id="portfolio-status-count"></span>
        </div>
        <div class="portfolio-meta-grid">
          <div class="portfolio-summary-card">
            <h4>Coverage</h4>
            <p class="summary-value" id="portfolio-summary-overview">-</p>
            <p class="status-subtle" id="portfolio-summary-subtext">
              Configured bots will appear once detected.
            </p>
          </div>
          <div class="portfolio-summary-card">
            <h4>Positioning</h4>
            <p class="summary-value" id="portfolio-summary-positions">-</p>
            <p class="status-subtle" id="portfolio-summary-capital">-</p>
          </div>
          <div class="portfolio-summary-card">
            <h4>Leaders</h4>
            <p class="summary-value" id="portfolio-summary-leaders">-</p>
            <p class="status-subtle" id="portfolio-summary-laggards">-</p>
          </div>
          <div class="portfolio-summary-card portfolio-guard-card">
            <h4>Safety Controls</h4>
            <p class="summary-value" id="portfolio-summary-guard">-</p>
            <p class="status-subtle" id="portfolio-summary-guard-note">
              Pause bots instantly when volatility spikes.
            </p>
            <ul id="portfolio-guard-list">
              <li class="status-subtle">No manual pauses logged.</li>
            </ul>
          </div>
        </div>
        <p class="status-subtle" id="portfolio-status-empty">
          No multi-market bots have reported their state yet.
        </p>
        <div class="portfolio-status-grid" id="portfolio-status-grid"></div>
        <div class="portfolio-chart-card">
          <div class="chart-card-header">
            <h4>Capital Allocation</h4>
            <span class="chart-note" id="portfolio-allocation-summary"></span>
          </div>
          <canvas id="portfolio-allocation-canvas" class="chart-canvas"></canvas>
          <p class="status-subtle" id="portfolio-allocation-empty">
            Allocation chart will populate once the bots publish balances.
          </p>
        </div>
        <p id="portfolio-status-error" class="error"></p>
      </div>
    </section>

    <section>
      <h2>AI Insights</h2>
      <div class="ai-grid">
        <div class="ai-card">
          <span class="ai-label">Recommended Action</span>
          <span class="ai-value" id="ai-action">-</span>
          <span class="status-subtle" id="ai-confidence">Confidence: -</span>
        </div>
        <div class="ai-card">
          <span class="ai-label">Expected Move</span>
          <span class="ai-value" id="ai-expected-move">-</span>
          <span class="status-subtle" id="ai-summary-short">-</span>
        </div>
        <div class="ai-card">
          <span class="ai-label">Feature Snapshot</span>
          <span class="status-subtle" id="ai-features">-</span>
        </div>
      </div>
      <div class="ai-probabilities">
        <div>
          <span>Long</span>
          <strong id="ai-prob-long">-</strong>
        </div>
        <div>
          <span>Short</span>
          <strong id="ai-prob-short">-</strong>
        </div>
        <div>
          <span>Flat</span>
          <strong id="ai-prob-flat">-</strong>
        </div>
      </div>
      <div class="chart-card">
        <div class="chart-card-header">
          <h3>Probability Mix</h3>
          <span class="chart-note">Live share of LONG / SHORT / FLAT confidence.</span>
        </div>
        <canvas id="ai-probability-chart" class="chart-canvas"></canvas>
        <p class="status-subtle" id="ai-probability-empty">
          Probability graph will update once the AI layer publishes predictions.
        </p>
      </div>
      <p class="ai-summary" id="ai-summary">AI summary will appear here once data is available.</p>
      <p id="ai-error" class="error"></p>
      <div class="question-box">
        <h3>Ask the Strategy Assistant</h3>
        <form id="ai-question-form">
          <input type="text" id="ai-question-input" placeholder="When should I buy?" autocomplete="off" />
          <button type="submit" id="ai-question-submit">Ask</button>
        </form>
        <p id="ai-question-feedback" class="error"></p>
        <p id="ai-answer" class="question-answer">Ask about buy, sell, risk, macro catalysts, or the AI model to get guidance.</p>
      </div>
    </section>

    <section>
      <h2>Macro &amp; News Pulse</h2>
      <div class="macro-grid">
        <div class="macro-card">
          <span class="macro-label">Bias Score</span>
          <span class="macro-value" id="macro-bias">-</span>
          <span class="status-subtle" id="macro-confidence">Confidence: -</span>
        </div>
        <div class="macro-card">
          <span class="macro-label">Interest Rate Outlook</span>
          <span class="status-subtle" id="macro-rates">-</span>
        </div>
        <div class="macro-card">
          <span class="macro-label">Political Watch</span>
          <span class="status-subtle" id="macro-politics">-</span>
        </div>
      </div>
      <p class="macro-summary" id="macro-summary">Macro catalyst summaries will appear here once data is available.</p>
      <ul class="macro-drivers" id="macro-drivers"></ul>
      <div class="macro-events">
        <h3>Recent Catalysts</h3>
        <ul id="macro-events-list"></ul>
      </div>
      <p id="macro-error" class="error"></p>
    </section>

    <section>
      <h2>Multi-Market Portfolio Playbook</h2>
      <p class="status-subtle" id="playbook-updated">Playbook loading...</p>
      <div id="playbook-highlights" class="playbook-highlights"></div>
      <div class="playbook-container">
        <div class="playbook-group">
          <h3>Commodities, Crypto &amp; Metals</h3>
          <div id="playbook-commodities"></div>
        </div>
        <div class="playbook-group">
          <h3>Large-Cap Equities</h3>
          <div id="playbook-equities"></div>
        </div>
      </div>
      <p id="playbook-error" class="error"></p>
    </section>

    <section>
      <h2>Decision Playbook</h2>
      <div class="strategy-grid">
        <div class="strategy-card">
          <span class="strategy-label">Symbol</span>
          <span class="strategy-value" id="strategy-symbol">-</span>
        </div>
        <div class="strategy-card">
          <span class="strategy-label">Timeframe</span>
          <span class="strategy-value" id="strategy-timeframe">-</span>
        </div>
        <div class="strategy-card">
          <span class="strategy-label">EMA Fast / Slow</span>
          <span class="strategy-value" id="strategy-ema">-</span>
        </div>
        <div class="strategy-card">
          <span class="strategy-label">RSI Period</span>
          <span class="strategy-value" id="strategy-rsi-period">-</span>
          <span class="strategy-subtle" id="strategy-rsi-bands">-</span>
        </div>
        <div class="strategy-card">
          <span class="strategy-label">Stop / Take Profit</span>
          <span class="strategy-value" id="strategy-risk-bounds">-</span>
          <span class="strategy-subtle" id="strategy-risk">-</span>
        </div>
      </div>
      <div class="strategy-rules">
        <div>
          <h3>Buy / Sell Triggers</h3>
          <ul id="decision-rules"></ul>
        </div>
        <div>
          <h3>Risk Management</h3>
          <ul id="risk-rules"></ul>
        </div>
      </div>
    </section>

    <section>
      <h2>Recent Signals</h2>
      <table>
        <thead>
          <tr>
            <th>Timestamp</th>
            <th>Decision</th>
            <th>Confidence</th>
            <th>AI View</th>
            <th>AI Move</th>
            <th>Reason</th>
          </tr>
        </thead>
        <tbody id="signals-body">
          <tr>
            <td colspan="5">Loading...</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section>
      <h2>Equity Curve</h2>
      <div class="chart-card">
        <canvas id="equity-canvas" class="chart-canvas"></canvas>
      </div>
    </section>

    <script>
      const statusSymbol = document.getElementById("status-symbol");
      const statusPosition = document.getElementById("status-position");
      const statusBalance = document.getElementById("status-balance");
      const statusEntry = document.getElementById("status-entry");
      const statusPnL = document.getElementById("status-pnl");
      const statusSignal = document.getElementById("status-signal");
      const statusConfidence = document.getElementById("status-confidence");
      const statusRisk = document.getElementById("status-risk");
      const statusError = document.getElementById("status-error");
      const portfolioStatusSection = document.getElementById("portfolio-status-section");
      const portfolioStatusGrid = document.getElementById("portfolio-status-grid");
      const portfolioStatusEmpty = document.getElementById("portfolio-status-empty");
      const portfolioStatusCount = document.getElementById("portfolio-status-count");
      const portfolioStatusError = document.getElementById("portfolio-status-error");
      const portfolioSummaryOverview = document.getElementById(
        "portfolio-summary-overview",
      );
      const portfolioSummarySubtext = document.getElementById(
        "portfolio-summary-subtext",
      );
      const portfolioSummaryPositions = document.getElementById(
        "portfolio-summary-positions",
      );
      const portfolioSummaryCapital = document.getElementById(
        "portfolio-summary-capital",
      );
      const portfolioSummaryLeaders = document.getElementById(
        "portfolio-summary-leaders",
      );
      const portfolioSummaryLaggards = document.getElementById(
        "portfolio-summary-laggards",
      );
      const portfolioSummaryGuard = document.getElementById(
        "portfolio-summary-guard",
      );
      const portfolioSummaryGuardNote = document.getElementById(
        "portfolio-summary-guard-note",
      );
      const portfolioGuardList = document.getElementById("portfolio-guard-list");
      const lastUpdated = document.getElementById("last-updated");
      const signalsBody = document.getElementById("signals-body");
      const equityCanvas = document.getElementById("equity-canvas");
      const aiProbabilityCanvas = document.getElementById("ai-probability-chart");
      const aiProbabilityEmpty = document.getElementById("ai-probability-empty");
      const portfolioAllocationCanvas = document.getElementById("portfolio-allocation-canvas");
      const portfolioAllocationSummary = document.getElementById("portfolio-allocation-summary");
      const portfolioAllocationEmpty = document.getElementById("portfolio-allocation-empty");
      const previewBadge = document.getElementById("preview-badge");

      const strategySymbol = document.getElementById("strategy-symbol");
      const strategyTimeframe = document.getElementById("strategy-timeframe");
      const strategyEma = document.getElementById("strategy-ema");
      const strategyRsiPeriod = document.getElementById("strategy-rsi-period");
      const strategyRsiBands = document.getElementById("strategy-rsi-bands");
      const strategyRiskBounds = document.getElementById("strategy-risk-bounds");
      const strategyRisk = document.getElementById("strategy-risk");
      const decisionRules = document.getElementById("decision-rules");
      const riskRules = document.getElementById("risk-rules");

      const aiAction = document.getElementById("ai-action");
      const aiConfidence = document.getElementById("ai-confidence");
      const aiExpectedMove = document.getElementById("ai-expected-move");
      const aiSummaryShort = document.getElementById("ai-summary-short");
      const aiSummary = document.getElementById("ai-summary");
      const aiProbLong = document.getElementById("ai-prob-long");
      const aiProbShort = document.getElementById("ai-prob-short");
      const aiProbFlat = document.getElementById("ai-prob-flat");
      const aiFeatures = document.getElementById("ai-features");
      const aiError = document.getElementById("ai-error");
      const aiQuestionForm = document.getElementById("ai-question-form");
      const aiQuestionInput = document.getElementById("ai-question-input");
      const aiQuestionSubmit = document.getElementById("ai-question-submit");
      const aiQuestionFeedback = document.getElementById("ai-question-feedback");
      const aiAnswer = document.getElementById("ai-answer");

      const macroBias = document.getElementById("macro-bias");
      const macroConfidence = document.getElementById("macro-confidence");
      const macroRates = document.getElementById("macro-rates");
      const macroPolitics = document.getElementById("macro-politics");
      const macroSummary = document.getElementById("macro-summary");
      const macroDrivers = document.getElementById("macro-drivers");
      const macroEventsList = document.getElementById("macro-events-list");
      const macroError = document.getElementById("macro-error");

      const playbookUpdated = document.getElementById("playbook-updated");
      const playbookHighlights = document.getElementById("playbook-highlights");
      const playbookCommodities = document.getElementById("playbook-commodities");
      const playbookEquities = document.getElementById("playbook-equities");
      const playbookError = document.getElementById("playbook-error");

      const ctx = equityCanvas.getContext("2d");
      const aiProbabilityCtx = aiProbabilityCanvas
        ? aiProbabilityCanvas.getContext("2d")
        : null;
      const portfolioAllocationCtx = portfolioAllocationCanvas
        ? portfolioAllocationCanvas.getContext("2d")
        : null;

      const CHART_COLORS = [
        "#38bdf8",
        "#f472b6",
        "#facc15",
        "#a78bfa",
        "#34d399",
        "#fb7185",
        "#f97316",
        "#22d3ee",
      ];

      const urlParams = new URLSearchParams(window.location.search);
      const isPreviewMode = urlParams.get("demo") === "1" || window.location.pathname.includes("preview");
      previewBadge.classList.toggle("hidden", !isPreviewMode);

      let latestAiSnapshot = null;
      let latestEquityPoints = [];
      let latestPortfolioStatuses = [];

      const PREVIEW_STATE = {
        symbol: "XAU/USD",
        position: "LONG",
        entry_price: 2368.2,
        position_size: 1.4,
        balance: 10000,
        unrealized_pnl_pct: 0.62,
        last_signal: "LONG",
        confidence: 0.66,
        risk_per_trade_pct: 0.4,
        initial_balance: 10000,
      };

      const PREVIEW_PORTFOLIO_STATES = [
        {
          timestamp: new Date().toISOString(),
          symbol: "XAU/USD",
          position: "LONG",
          position_size: 1.25,
          balance: 10280,
          initial_balance: 10000,
          entry_price: 2365.2,
          unrealized_pnl_pct: 0.82,
          last_signal: "LONG",
          confidence: 0.64,
          risk_per_trade_pct: 0.4,
          ai_action: "LONG",
          ai_confidence: 0.62,
          data_directory: "portfolio/xauusd",
          asset_type: "commodity",
          timeframe: "1h",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 180,
          stop_loss_pct: 0.012,
          take_profit_pct: 0.024,
          is_paused: false,
          pause_reason: null,
          pause_updated_at: null,
          is_placeholder: false,
        },
        {
          timestamp: new Date().toISOString(),
          symbol: "XAG/USD",
          position: "FLAT",
          position_size: 0,
          balance: 10020,
          initial_balance: 10000,
          entry_price: null,
          unrealized_pnl_pct: -0.12,
          last_signal: "FLAT",
          confidence: 0.48,
          risk_per_trade_pct: 0.4,
          ai_action: "FLAT",
          ai_confidence: 0.51,
          data_directory: "portfolio/xagusd",
          asset_type: "commodity",
          timeframe: "1h",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 180,
          stop_loss_pct: 0.012,
          take_profit_pct: 0.024,
          is_paused: false,
          pause_reason: null,
          pause_updated_at: null,
          is_placeholder: false,
        },
        {
          timestamp: new Date().toISOString(),
          symbol: "USOIL/USD",
          position: "SHORT",
          position_size: 8.2,
          balance: 9950,
          initial_balance: 10000,
          entry_price: 76.8,
          unrealized_pnl_pct: -0.22,
          last_signal: "SHORT",
          confidence: 0.55,
          risk_per_trade_pct: 0.35,
          ai_action: "SHORT",
          ai_confidence: 0.58,
          data_directory: "portfolio/usoilusd",
          asset_type: "commodity",
          timeframe: "1h",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 240,
          stop_loss_pct: 0.015,
          take_profit_pct: 0.03,
          is_paused: true,
          pause_reason: "Awaiting OPEC headlines",
          pause_updated_at: new Date(Date.now() - 15 * 60_000).toISOString(),
          is_placeholder: false,
        },
        {
          timestamp: new Date().toISOString(),
          symbol: "ETH/USDT",
          position: "LONG",
          position_size: 2.8,
          balance: 10090,
          initial_balance: 10000,
          entry_price: 3645.8,
          unrealized_pnl_pct: 0.36,
          last_signal: "LONG",
          confidence: 0.58,
          risk_per_trade_pct: 0.45,
          ai_action: "LONG",
          ai_confidence: 0.57,
          data_directory: "portfolio/ethusdt",
          asset_type: "crypto",
          timeframe: "30m",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 300,
          stop_loss_pct: 0.01,
          take_profit_pct: 0.02,
          is_paused: false,
          pause_reason: null,
          pause_updated_at: null,
          is_placeholder: false,
        },
        {
          timestamp: new Date().toISOString(),
          symbol: "NVDA",
          position: "FLAT",
          position_size: 0,
          balance: 10000,
          initial_balance: 10000,
          entry_price: null,
          unrealized_pnl_pct: 0.0,
          last_signal: "FLAT",
          confidence: 0.5,
          risk_per_trade_pct: 0.35,
          ai_action: "FLAT",
          ai_confidence: 0.5,
          data_directory: "portfolio/nvda",
          asset_type: "equity",
          timeframe: "1h",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 300,
          stop_loss_pct: 0.009,
          take_profit_pct: 0.018,
          is_paused: false,
          pause_reason: null,
          pause_updated_at: null,
          is_placeholder: false,
        },
        {
          timestamp: new Date().toISOString(),
          symbol: "MSFT",
          position: "LONG",
          position_size: 1.6,
          balance: 10110,
          initial_balance: 10000,
          entry_price: 418.2,
          unrealized_pnl_pct: 0.24,
          last_signal: "LONG",
          confidence: 0.6,
          risk_per_trade_pct: 0.3,
          ai_action: "LONG",
          ai_confidence: 0.56,
          data_directory: "portfolio/msft",
          asset_type: "equity",
          timeframe: "1h",
          allocation_pct: 16.7,
          paper_mode: true,
          loop_interval_seconds: 300,
          stop_loss_pct: 0.008,
          take_profit_pct: 0.016,
          is_paused: false,
          pause_reason: null,
          pause_updated_at: null,
          is_placeholder: false,
        },
      ];

      const PREVIEW_AI = {
        recommended_action: "LONG",
        confidence: 0.72,
        probability_long: 0.72,
        probability_short: 0.18,
        probability_flat: 0.1,
        expected_move_pct: 0.64,
        summary:
          "Model leans upside with 72.0% confidence driven by EMA spread 0.48% and momentum 0.35%.",
        features: {
          ema_gap_pct: 0.48,
          momentum_pct: 0.35,
          rsi_distance_from_mid: 8.5,
          volatility_pct: 0.62,
        },
      };

      const PREVIEW_MACRO = {
        bias_score: -0.18,
        confidence: 0.58,
        summary:
          "Macro bias is bearish (-0.18) based on 3 tracked catalysts. Fed watch: Fed likely to keep rates unchanged but watch core inflation prints. Political risk: Donald Trump: Potential tariff escalation keeps risk assets cautious.",
        drivers: [
          "Trump vows fresh tariffs review (bearish, high impact)",
          "US payrolls surprise to upside (hawkish, high impact)",
        ],
        interest_rate_outlook: "Fed likely to keep rates unchanged but watch core inflation prints.",
        political_risk: "Donald Trump: Potential tariff escalation keeps risk assets cautious.",
        events: [
          {
            title: "Trump vows fresh tariffs review",
            sentiment: "bearish",
            impact: "high",
            actor: "Donald Trump",
            summary: "Potential tariff escalation keeps risk assets cautious.",
          },
          {
            title: "Fed officials guide for data-dependent path",
            sentiment: "neutral",
            impact: "medium",
            interest_rate_expectation:
              "Fed likely to keep rates unchanged but watch core inflation prints.",
          },
          {
            title: "US payrolls surprise to upside",
            sentiment: "hawkish",
            impact: "high",
            summary: "Stronger labor data tempers rate-cut odds.",
          },
        ],
      };

      const PREVIEW_SIGNALS = [
        {
          symbol: "XAU/USD",
          decision: "LONG",
          confidence: 0.74,
          reason: "Gold momentum stays constructive above EMA stack.",
          ai_action: "LONG",
          ai_confidence: 0.7,
          ai_expected_move_pct: 0.35,
        },
        {
          symbol: "XAU/USD",
          decision: "FLAT",
          confidence: 0.58,
          reason: "RSI midline rejection triggered risk filter.",
          ai_action: "FLAT",
          ai_confidence: 0.52,
          ai_expected_move_pct: 0.08,
        },
        {
          symbol: "XAU/USD",
          decision: "SHORT",
          confidence: 0.62,
          reason: "EMA fast slipped below EMA slow with RSI divergence.",
          ai_action: "SHORT",
          ai_confidence: 0.6,
          ai_expected_move_pct: -0.28,
        },
        {
          symbol: "XAG/USD",
          decision: "LONG",
          confidence: 0.57,
          reason: "Silver mean reversion bounce with supportive macro bias.",
          ai_action: "LONG",
          ai_confidence: 0.55,
          ai_expected_move_pct: 0.18,
        },
      ];

      const PREVIEW_EQUITY_BASE = Array.from({ length: 32 }, (_, index) => 10000 + index * 24 + Math.sin(index / 1.8) * 18);

      const PREVIEW_STRATEGY = {
        symbol: "XAU/USD",
        timeframe: "1h",
        ema_fast: 12,
        ema_slow: 34,
        rsi_period: 14,
        rsi_overbought: 69,
        rsi_oversold: 31,
        risk_per_trade_pct: 0.4,
        stop_loss_pct: 0.006,
        take_profit_pct: 0.012,
        decision_rules: [
          "Go LONG when the fast EMA crosses above the slow EMA and RSI stays below the overbought threshold.",
          "Go SHORT when the fast EMA crosses below the slow EMA and RSI stays above the oversold threshold.",
          "Fallback LONG when RSI dips below the oversold threshold even without a crossover.",
          "Fallback SHORT when RSI rises above the overbought threshold even without a crossover.",
        ],
        risk_management_notes: [
          "Risk per trade is capped by the configured percentage of the current balance.",
          "Stop-loss and take-profit levels are derived from the last entry price and the configured percentages.",
          "Position sizing scales inversely with stop distance to maintain consistent risk exposure.",
        ],
      };

      const PREVIEW_PLAYBOOK = {
        generated_at: new Date().toISOString(),
        starting_balance: 10000,
        highlights: [
          "Gold leads commodities on the swing horizon (+1.20%).",
          "Ether rotation remains cautious while crude fades.",
          "Average macro bias across tracked assets: +0.08.",
        ],
        commodities: [
          {
            symbol: "XAU/USD",
            asset_class: "commodity",
            macro_bias: 0.22,
            macro_confidence: 0.64,
            macro_summary: "Bullion demand improves as rate-cut odds creep higher.",
            macro_drivers: [
              "FOMC statement (dovish, medium impact)",
              "Physical buying out of Asia (supportive, medium impact)",
            ],
            macro_interest_rate_outlook: "Fed signals a cautious cut later this year.",
            macro_political_risk: "Tariff policy uncertainty keeps safe-haven bids alive.",
            horizons: [
              {
                label: "short",
                timeframe: "1h",
                candles_tested: 640,
                initial_balance: 10000,
                final_balance: 10120,
                total_return_pct: 1.2,
                annualized_return_pct: 18.4,
                sharpe_ratio: 1.1,
                win_rate: 57.2,
                trades: 28,
                macro_bias: 0.22,
                macro_summary: "Bullion demand improves as rate-cut odds creep higher.",
              },
              {
                label: "swing",
                timeframe: "4h",
                candles_tested: 480,
                initial_balance: 10000,
                final_balance: 10210,
                total_return_pct: 2.1,
                annualized_return_pct: 26.5,
                sharpe_ratio: 1.25,
                win_rate: 59.5,
                trades: 22,
                macro_bias: 0.22,
                macro_summary: "Bullion demand improves as rate-cut odds creep higher.",
              },
            ],
            notes: [
              "Best horizon: swing (+2.10% return).",
              "Macro stance remains bullish (bias +0.22, confidence 0.64).",
              "Watch for CPI prints to confirm rate-cut narrative.",
            ],
          },
          {
            symbol: "ETH/USDT",
            asset_class: "crypto",
            macro_bias: 0.05,
            macro_confidence: 0.52,
            macro_summary: "Rotation stays choppy as liquidity hunts alt L1s.",
            macro_drivers: [
              "Spot ETF inflows (bullish, medium impact)",
              "Dollar strength (bearish, medium impact)",
            ],
            macro_interest_rate_outlook: "Crypto volatility still tied to dollar swings.",
            macro_political_risk: "US ETF approvals under ongoing review.",
            horizons: [
              {
                label: "rotation",
                timeframe: "30m",
                candles_tested: 720,
                initial_balance: 10000,
                final_balance: 10068,
                total_return_pct: 0.68,
                annualized_return_pct: 14.2,
                sharpe_ratio: 0.74,
                win_rate: 54.1,
                trades: 32,
                macro_bias: 0.05,
                macro_summary: "Rotation stays choppy as liquidity hunts alt L1s.",
              },
              {
                label: "trend",
                timeframe: "2h",
                candles_tested: 360,
                initial_balance: 10000,
                final_balance: 10132,
                total_return_pct: 1.32,
                annualized_return_pct: 17.9,
                sharpe_ratio: 0.92,
                win_rate: 55.6,
                trades: 20,
                macro_bias: 0.05,
                macro_summary: "Rotation stays choppy as liquidity hunts alt L1s.",
              },
            ],
            notes: [
              "Best horizon: trend (+1.32% return).",
              "Macro stance is balanced (bias +0.05, confidence 0.52).",
              "Watch ETF flow data for confirmation.",
            ],
          },
          {
            symbol: "USOIL/USD",
            asset_class: "commodity",
            macro_bias: -0.12,
            macro_confidence: 0.57,
            macro_summary: "Crude sags as supply rebounds and demand revisions bite.",
            macro_drivers: [
              "DOE inventory build (bearish, medium impact)",
              "China PMI wobble (bearish, high impact)",
            ],
            macro_interest_rate_outlook: "Higher for longer keeps demand expectations muted.",
            macro_political_risk: "OPEC+ cohesion under scrutiny as prices slip.",
            horizons: [
              {
                label: "intraday",
                timeframe: "1h",
                candles_tested: 600,
                initial_balance: 10000,
                final_balance: 9988,
                total_return_pct: -0.12,
                annualized_return_pct: -1.8,
                sharpe_ratio: -0.24,
                win_rate: 46.2,
                trades: 30,
                macro_bias: -0.12,
                macro_summary: "Crude sags as supply rebounds and demand revisions bite.",
              },
              {
                label: "macro",
                timeframe: "4h",
                candles_tested: 420,
                initial_balance: 10000,
                final_balance: 9965,
                total_return_pct: -0.35,
                annualized_return_pct: -4.6,
                sharpe_ratio: -0.41,
                win_rate: 44.8,
                trades: 18,
                macro_bias: -0.12,
                macro_summary: "Crude sags as supply rebounds and demand revisions bite.",
              },
            ],
            notes: [
              "Best horizon: intraday (-0.12% return).",
              "Macro stance is bearish (bias -0.12, confidence 0.57).",
              "Focus on DOE/IEA data to confirm the downside.",
            ],
          },
          {
            symbol: "XAG/USD",
            asset_class: "commodity",
            macro_bias: -0.04,
            macro_confidence: 0.49,
            macro_summary: "Silver chops sideways as industrial demand cools.",
            macro_drivers: [
              "Manufacturing surveys (bearish, medium impact)",
              "Gold beta (supportive, low impact)",
            ],
            macro_interest_rate_outlook: "Range-bound rates keep silver tethered to gold.",
            macro_political_risk: "Trade rhetoric keeps volatility elevated.",
            horizons: [
              {
                label: "short",
                timeframe: "1h",
                candles_tested: 640,
                initial_balance: 10000,
                final_balance: 9996,
                total_return_pct: -0.04,
                annualized_return_pct: -0.6,
                sharpe_ratio: -0.08,
                win_rate: 48.1,
                trades: 26,
                macro_bias: -0.04,
                macro_summary: "Silver chops sideways as industrial demand cools.",
              },
              {
                label: "carry",
                timeframe: "4h",
                candles_tested: 420,
                initial_balance: 10000,
                final_balance: 10032,
                total_return_pct: 0.32,
                annualized_return_pct: 4.2,
                sharpe_ratio: 0.35,
                win_rate: 52.2,
                trades: 16,
                macro_bias: -0.04,
                macro_summary: "Silver chops sideways as industrial demand cools.",
              },
            ],
            notes: [
              "Best horizon: carry (+0.32% return).",
              "Macro stance is flat (bias -0.04, confidence 0.49).",
              "Need stronger PMI data for a decisive push.",
            ],
          },
        ],
        equities: [
          {
            symbol: "NVDA",
            asset_class: "equity",
            macro_bias: 0.14,
            macro_confidence: 0.6,
            macro_summary: "AI hardware cycle keeps earnings revisions trending up.",
            macro_drivers: [
              "AI capex plans (bullish, high impact)",
              "FOMC statement (dovish, medium impact)",
            ],
            macro_interest_rate_outlook: "Lower yields extend duration appetite for growth stocks.",
            macro_political_risk: "Export controls remain a headline risk but manageable.",
            horizons: [
              {
                label: "short",
                timeframe: "1h",
                candles_tested: 600,
                initial_balance: 10000,
                final_balance: 10078,
                total_return_pct: 0.78,
                annualized_return_pct: 12.8,
                sharpe_ratio: 0.71,
                win_rate: 55.2,
                trades: 24,
                macro_bias: 0.14,
                macro_summary: "AI hardware cycle keeps earnings revisions trending up.",
              },
              {
                label: "position",
                timeframe: "4h",
                candles_tested: 360,
                initial_balance: 10000,
                final_balance: 10280,
                total_return_pct: 2.8,
                annualized_return_pct: 32.5,
                sharpe_ratio: 1.18,
                win_rate: 60.1,
                trades: 15,
                macro_bias: 0.14,
                macro_summary: "AI hardware cycle keeps earnings revisions trending up.",
              },
            ],
            notes: [
              "Best horizon: position (+2.80% return).",
              "Macro stance is supportive (bias +0.14, confidence 0.60).",
              "Keep an eye on export-control headlines.",
            ],
          },
          {
            symbol: "MSFT",
            asset_class: "equity",
            macro_bias: 0.08,
            macro_confidence: 0.6,
            macro_summary: "Cloud demand holds firm as enterprise budgets normalize.",
            macro_drivers: [
              "AI investment cycle (growth, medium impact)",
              "FOMC statement (dovish, medium impact)",
            ],
            macro_interest_rate_outlook: "Stable policy path underpins tech multiples.",
            macro_political_risk: "Antitrust scrutiny manageable relative to peers.",
            horizons: [
              {
                label: "short",
                timeframe: "1h",
                candles_tested: 600,
                initial_balance: 10000,
                final_balance: 10066,
                total_return_pct: 0.66,
                annualized_return_pct: 10.4,
                sharpe_ratio: 0.64,
                win_rate: 54.3,
                trades: 20,
                macro_bias: 0.08,
                macro_summary: "Cloud demand holds firm as enterprise budgets normalize.",
              },
              {
                label: "long",
                timeframe: "4h",
                candles_tested: 360,
                initial_balance: 10000,
                final_balance: 10240,
                total_return_pct: 2.4,
                annualized_return_pct: 28.1,
                sharpe_ratio: 1.02,
                win_rate: 58.7,
                trades: 14,
                macro_bias: 0.08,
                macro_summary: "Cloud demand holds firm as enterprise budgets normalize.",
              },
            ],
            notes: [
              "Best horizon: long (+2.40% return).",
              "Macro stance is supportive (bias +0.08, confidence 0.60).",
              "Monitor enterprise AI spend for confirmation.",
            ],
          },
        ],
      };

      function escapeHtml(value) {
        if (typeof value !== "string") {
          return "";
        }
        return value
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function formatNumber(value, fractionDigits = 2) {
        return typeof value === "number" && Number.isFinite(value)
          ? value.toLocaleString(undefined, {
              minimumFractionDigits: fractionDigits,
              maximumFractionDigits: fractionDigits,
            })
          : "-";
      }

      function formatPercent(value, fractionDigits = 2) {
        return typeof value === "number" && Number.isFinite(value)
          ? `${value.toFixed(fractionDigits)} %`
          : "-";
      }

      function formatSignedPercent(value, fractionDigits = 2) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return "-";
        }
        const sign = value > 0 ? "+" : value < 0 ? "" : "";
        return `${sign}${value.toFixed(fractionDigits)} %`;
      }

      function formatRatioPercent(value, fractionDigits = 1) {
        return typeof value === "number" && Number.isFinite(value)
          ? `${(value * 100).toFixed(fractionDigits)} %`
          : "-";
      }

      function formatRelativeTime(timestamp) {
        if (!timestamp) {
          return null;
        }
        const date = new Date(timestamp);
        if (Number.isNaN(date.getTime())) {
          return null;
        }
        const diffMs = Date.now() - date.getTime();
        if (diffMs < 45_000) {
          return "moments ago";
        }
        const diffMinutes = Math.round(diffMs / 60_000);
        if (diffMinutes < 60) {
          return `${diffMinutes} min${diffMinutes === 1 ? "" : "s"} ago`;
        }
        const diffHours = Math.round(diffMinutes / 60);
        if (diffHours < 24) {
          return `${diffHours} hr${diffHours === 1 ? "" : "s"} ago`;
        }
        const diffDays = Math.round(diffHours / 24);
        return `${diffDays} d${diffDays === 1 ? "" : "s"} ago`;
      }

      function formatFeatureSnapshot(features) {
        if (!features) {
          return "-";
        }
        const parts = [];
        if (typeof features.ema_gap_pct === "number") {
          parts.push(`EMA gap ${features.ema_gap_pct.toFixed(2)}%`);
        }
        if (typeof features.momentum_pct === "number") {
          parts.push(`Momentum ${features.momentum_pct.toFixed(2)}%`);
        }
        if (typeof features.rsi_distance_from_mid === "number") {
          parts.push(
            `RSI bias ${features.rsi_distance_from_mid.toFixed(2)}%`
          );
        }
        if (typeof features.volatility_pct === "number") {
          parts.push(`Volatility ${features.volatility_pct.toFixed(2)}%`);
        }
        return parts.length ? parts.join("  ") : "-";
      }

      function formatBias(value) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
          return "-";
        }
        const tone = value > 0.05 ? "Bullish" : value < -0.05 ? "Bearish" : "Balanced";
        return `${value.toFixed(2)} (${tone})`;
      }

      function formatMacroEvent(event) {
        if (!event || !event.title) {
          return null;
        }
        const pieces = [event.title];
        if (event.sentiment) {
          pieces.push(` ${event.sentiment}`);
        }
        if (event.impact) {
          pieces.push(`[${event.impact} impact]`);
        }
        if (event.actor) {
          pieces.push(`(${event.actor})`);
        }
        const context =
          event.summary || event.interest_rate_expectation || event.source || event.timestamp;
        if (context) {
          pieces.push(`: ${context}`);
        }
        return pieces.join(" ");
      }

      function titleCase(text) {
        if (!text) {
          return "";
        }
        return text.charAt(0).toUpperCase() + text.slice(1);
      }

      function prepareCanvas(canvas, context) {
        if (!canvas || !context) {
          return { width: 0, height: 0, ready: false };
        }
        const width = canvas.clientWidth || canvas.parentElement?.clientWidth || 0;
        const height = canvas.clientHeight || canvas.parentElement?.clientHeight || 0;
        if (!width || !height) {
          canvas.width = 0;
          canvas.height = 0;
          return { width, height, ready: false };
        }
        const ratio = window.devicePixelRatio || 1;
        canvas.width = width * ratio;
        canvas.height = height * ratio;
        context.setTransform(ratio, 0, 0, ratio, 0, 0);
        context.clearRect(0, 0, width, height);
        return { width, height, ready: true };
      }

      function drawEquityCurve(points) {
        latestEquityPoints = Array.isArray(points) ? points.slice() : [];
        const { width, height, ready } = prepareCanvas(equityCanvas, ctx);

        if (!ready || !points.length) {
          return;
        }

        const values = points.map((point) => point.value);
        const min = Math.min(...values);
        const max = Math.max(...values);
        const range = max - min || 1;

        ctx.lineWidth = 2;
        ctx.strokeStyle = "#38bdf8";
        ctx.beginPath();
        points.forEach((point, index) => {
          const x = (index / Math.max(points.length - 1, 1)) * width;
          const y = height - ((point.value - min) / range) * height;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.stroke();

        ctx.fillStyle = "rgba(56, 189, 248, 0.18)";
        ctx.beginPath();
        points.forEach((point, index) => {
          const x = (index / Math.max(points.length - 1, 1)) * width;
          const y = height - ((point.value - min) / range) * height;
          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        ctx.fill();
      }

      function drawAiProbabilityChart(ai) {
        if (!aiProbabilityCanvas || !aiProbabilityCtx) {
          return;
        }
        const { width, height, ready } = prepareCanvas(
          aiProbabilityCanvas,
          aiProbabilityCtx,
        );
        if (!ready) {
          if (aiProbabilityEmpty) {
            aiProbabilityEmpty.classList.remove("hidden");
          }
          return;
        }
        const dataset = [
          { label: "LONG", value: ai?.probability_long ?? 0, color: "#34d399" },
          { label: "SHORT", value: ai?.probability_short ?? 0, color: "#fb7185" },
          { label: "FLAT", value: ai?.probability_flat ?? 0, color: "#eab308" },
        ].map((entry) => ({
          ...entry,
          value:
            typeof entry.value === "number" && Number.isFinite(entry.value)
              ? Math.max(entry.value, 0)
              : 0,
        }));
        const hasProbabilities =
          ai &&
          ai.recommended_action &&
          dataset.some((entry) => entry.value > 0);
        if (!hasProbabilities) {
          if (aiProbabilityEmpty) {
            aiProbabilityEmpty.textContent = isPreviewMode
              ? "Preview probabilities will animate once the demo warms up."
              : "Probability graph will update once the AI layer publishes predictions.";
            aiProbabilityEmpty.classList.remove("hidden");
          }
          aiProbabilityCtx.fillStyle = "rgba(148, 163, 184, 0.8)";
          aiProbabilityCtx.font = "14px 'Inter', system-ui, sans-serif";
          aiProbabilityCtx.textAlign = "left";
          aiProbabilityCtx.textBaseline = "middle";
          aiProbabilityCtx.fillText("Awaiting AI probabilities...", 16, height / 2);
          return;
        }
        if (aiProbabilityEmpty) {
          aiProbabilityEmpty.classList.add("hidden");
        }
        aiProbabilityCtx.font = "13px 'Inter', system-ui, sans-serif";
        aiProbabilityCtx.textBaseline = "middle";
        aiProbabilityCtx.textAlign = "center";
        const maxValue = Math.max(...dataset.map((entry) => entry.value), 0.01);
        const barWidth = width / dataset.length;
        dataset.forEach((entry, index) => {
          const normalized = entry.value / maxValue;
          const barHeight = normalized * (height - 70);
          const x = index * barWidth + barWidth / 2;
          const barX = x - barWidth * 0.3;
          const barY = height - barHeight - 36;
          const barH = Math.max(barHeight, 4);
          aiProbabilityCtx.fillStyle = entry.color;
          aiProbabilityCtx.fillRect(barX, barY, barWidth * 0.6, barH);
          aiProbabilityCtx.fillStyle = "#e2e8f0";
          aiProbabilityCtx.fillText(`${(entry.value * 100).toFixed(1)}%`, x, barY - 12);
          aiProbabilityCtx.fillText(entry.label, x, height - 12);
        });
      }

      function drawPortfolioAllocationChart(statuses, preview = false) {
        if (!portfolioAllocationCanvas || !portfolioAllocationCtx) {
          return;
        }
        const normalized = Array.isArray(statuses) ? statuses : [];
        const { width, height, ready } = prepareCanvas(
          portfolioAllocationCanvas,
          portfolioAllocationCtx,
        );
        const dataset = normalized
          .map((state) => {
            const hasBalance =
              typeof state.balance === "number" && Number.isFinite(state.balance);
            const hasInitial =
              typeof state.initial_balance === "number" &&
              Number.isFinite(state.initial_balance);
            const balanceValue = hasBalance ? Math.max(state.balance, 0) : 0;
            const fallbackValue = hasInitial ? Math.max(state.initial_balance, 0) : 0;
            const value = balanceValue || fallbackValue;
            return {
              label: state.symbol || "-",
              value,
            };
          })
          .filter((entry) => entry.value > 0);
        if (!ready) {
          if (!dataset.length && portfolioAllocationEmpty) {
            portfolioAllocationEmpty.textContent = preview
              ? "Preview allocation chart will appear shortly."
              : "Allocation chart will populate once the bots publish balances.";
            portfolioAllocationEmpty.classList.remove("hidden");
          }
          if (portfolioAllocationSummary) {
            portfolioAllocationSummary.textContent = "";
          }
          return;
        }
        if (!dataset.length) {
          if (portfolioAllocationSummary) {
            portfolioAllocationSummary.textContent = "";
          }
          if (portfolioAllocationEmpty) {
            portfolioAllocationEmpty.textContent = preview
              ? "Preview allocation chart will appear shortly."
              : "Allocation chart will populate once the bots publish balances.";
            portfolioAllocationEmpty.classList.remove("hidden");
          }
          return;
        }
        if (portfolioAllocationEmpty) {
          portfolioAllocationEmpty.classList.add("hidden");
        }
        const total = dataset.reduce((sum, entry) => sum + entry.value, 0) || 1;
        const top = dataset.reduce(
          (acc, entry) => (entry.value > acc.value ? entry : acc),
          dataset[0],
        );
        if (portfolioAllocationSummary) {
          const topShare = ((top.value / total) * 100).toFixed(1);
          portfolioAllocationSummary.textContent = `Total deployed: ${formatNumber(
            total,
          )}  Top weight ${top.label} ${topShare}%`;
        }
        const leftMargin = 130;
        const rightMargin = 32;
        const availableWidth = Math.max(width - leftMargin - rightMargin, 24);
        const step = height / dataset.length;
        const barHeight = Math.max(10, step - 12);
        portfolioAllocationCtx.font = "12px 'Inter', system-ui, sans-serif";
        portfolioAllocationCtx.textBaseline = "middle";
        dataset.forEach((entry, index) => {
          const share = entry.value / total;
          const length = Math.max(share * availableWidth, 4);
          const y = index * step + step / 2;
          portfolioAllocationCtx.fillStyle = CHART_COLORS[index % CHART_COLORS.length];
          portfolioAllocationCtx.fillRect(leftMargin, y - barHeight / 2, length, barHeight);
          portfolioAllocationCtx.fillStyle = "#e2e8f0";
          portfolioAllocationCtx.textAlign = "right";
          portfolioAllocationCtx.fillText(entry.label, leftMargin - 12, y);
          portfolioAllocationCtx.textAlign = "left";
          portfolioAllocationCtx.fillText(`${(share * 100).toFixed(1)}%`, leftMargin + length + 8, y);
        });
      }

      function renderStrategy(strategy) {
        if (!strategy) {
          decisionRules.innerHTML = '<li>No strategy configuration available.</li>';
          riskRules.innerHTML = '<li>No risk notes available.</li>';
          return;
        }

        strategySymbol.textContent = strategy.symbol ?? "-";
        strategyTimeframe.textContent = strategy.timeframe ?? "-";
        strategyEma.textContent = `${strategy.ema_fast} / ${strategy.ema_slow}`;
        strategyRsiPeriod.textContent = strategy.rsi_period;
        strategyRsiBands.textContent = `Oversold  ${strategy.rsi_oversold}  Overbought  ${strategy.rsi_overbought}`;
        strategyRiskBounds.textContent = `${formatPercent(strategy.stop_loss_pct * 100)} SL  ${formatPercent(
          strategy.take_profit_pct * 100,
        )} TP`;
        strategyRisk.textContent = `Risk per trade: ${formatPercent(strategy.risk_per_trade_pct)}`;

        const decisionMarkup = (strategy.decision_rules || [])
          .map((rule) => `<li>${rule}</li>`)
          .join("");
        decisionRules.innerHTML = decisionMarkup || '<li>No decision rules configured.</li>';

        const riskMarkup = (strategy.risk_management_notes || [])
          .map((note) => `<li>${note}</li>`)
          .join("");
        riskRules.innerHTML = riskMarkup || '<li>No risk guidance configured.</li>';
      }

      function renderAI(ai, { preview } = { preview: false }) {
        aiError.textContent = "";

        if (!ai || !ai.recommended_action) {
          latestAiSnapshot = null;
          aiAction.textContent = "-";
          aiConfidence.textContent = "Confidence: -";
          aiExpectedMove.textContent = "-";
          aiSummaryShort.textContent = preview
            ? "Preview AI model warming up..."
            : "Waiting for live predictions.";
          aiSummary.textContent =
            "AI summary will appear here once data is available.";
          aiProbLong.textContent = "-";
          aiProbShort.textContent = "-";
          aiProbFlat.textContent = "-";
          aiFeatures.textContent = "-";
          if (!preview) {
            aiError.textContent =
              "AI insights will populate after the bot produces a few loops of data.";
          }
          drawAiProbabilityChart(null);
          return;
        }

        aiAction.textContent = ai.recommended_action;
        aiConfidence.textContent = `Confidence: ${formatRatioPercent(
          ai.confidence,
        )}`;
        aiExpectedMove.textContent = formatPercent(ai.expected_move_pct ?? null);
        const summaryText = ai.summary || "";
        aiSummaryShort.textContent = summaryText
          ? summaryText.split(".")[0] + "."
          : "-";
        aiSummary.textContent = summaryText || "-";
        aiProbLong.textContent = formatRatioPercent(ai.probability_long);
        aiProbShort.textContent = formatRatioPercent(ai.probability_short);
        aiProbFlat.textContent = formatRatioPercent(ai.probability_flat);
        aiFeatures.textContent = formatFeatureSnapshot(ai.features);
        latestAiSnapshot = { ...ai, features: { ...(ai.features || {}) } };
        drawAiProbabilityChart(latestAiSnapshot);
      }

      function renderMacro(macro, { preview } = { preview: false }) {
        macroError.textContent = "";

        if (!macro) {
          macroBias.textContent = "-";
          macroConfidence.textContent = "Confidence: -";
          macroRates.textContent = "-";
          macroPolitics.textContent = "-";
          macroSummary.textContent = preview
            ? "Preview macro context unavailable."
            : "No macro data loaded yet.";
          macroDrivers.innerHTML = "";
          macroEventsList.innerHTML = "";
          if (!preview) {
            macroError.textContent =
              "Unable to load macro insights. Ensure macro_events.json exists or provide MACRO_EVENTS_PATH.";
          }
          return;
        }

        macroBias.textContent = formatBias(macro.bias_score);
        macroConfidence.textContent = `Confidence: ${formatRatioPercent(
          macro.confidence ?? null,
        )}`;
        macroRates.textContent = macro.interest_rate_outlook || "-";
        macroPolitics.textContent = macro.political_risk || "-";
        macroSummary.textContent = macro.summary ||
          (preview
            ? "Macro bias oscillates in preview mode to simulate evolving catalysts."
            : "No macro summary provided yet.");

        const drivers = (macro.drivers || []).filter(Boolean);
        macroDrivers.innerHTML = drivers.length
          ? drivers.map((driver) => `<li>${driver}</li>`).join("")
          : '<li class="status-subtle">No dominant macro drivers logged.</li>';

        const events = (macro.events || [])
          .map((event) => formatMacroEvent(event))
          .filter(Boolean);
        macroEventsList.innerHTML = events.length
          ? events.map((event) => `<li>${event}</li>`).join("")
          : '<li class="status-subtle">No recent catalysts captured.</li>';
      }

      function renderPortfolioSummary(statuses, preview = false) {
        if (
          !portfolioSummaryOverview ||
          !portfolioSummarySubtext ||
          !portfolioSummaryPositions ||
          !portfolioSummaryCapital ||
          !portfolioSummaryLeaders ||
          !portfolioSummaryLaggards
        ) {
          return;
        }

        const normalized = Array.isArray(statuses) ? statuses : [];
        if (!normalized.length) {
          portfolioSummaryOverview.textContent = preview
            ? "Previewing configuration..."
            : "-";
          portfolioSummarySubtext.textContent =
            "Configured bots will appear once detected.";
          portfolioSummaryPositions.textContent = "Awaiting live positions";
          portfolioSummaryCapital.textContent = "-";
          portfolioSummaryLeaders.textContent = "-";
          portfolioSummaryLaggards.textContent = "-";
          if (portfolioSummaryGuard) {
            portfolioSummaryGuard.textContent = preview
              ? "Preview"
              : "-";
          }
          if (portfolioSummaryGuardNote) {
            portfolioSummaryGuardNote.textContent =
              "Pause bots instantly when volatility spikes.";
          }
          if (portfolioGuardList) {
            portfolioGuardList.innerHTML =
              '<li class="status-subtle">No manual pauses logged.</li>';
          }
          return;
        }

        const configuredCount = normalized.length;
        const reporting = normalized.filter((state) => !state.is_placeholder);
        const reportingCount = reporting.length;
        const pausedStates = normalized.filter((state) => state.is_paused);
        const typeCounts = normalized.reduce((acc, state) => {
          const key = (state.asset_type || "other").toLowerCase();
          acc[key] = (acc[key] || 0) + 1;
          return acc;
        }, {});
        const typeLine = Object.entries(typeCounts)
          .sort((a, b) => b[1] - a[1])
          .map(([type, count]) => `${titleCase(type)} ${count}`)
          .join("  ");

        portfolioSummaryOverview.textContent = `${configuredCount} configured`;
        portfolioSummarySubtext.textContent = [
          `${reportingCount} reporting`,
          typeLine,
        ]
          .filter(Boolean)
          .join("  ") || "Configured bots will appear once detected.";

        const totalInitial = normalized.reduce((sum, state) => {
          const value =
            typeof state.initial_balance === "number" &&
            Number.isFinite(state.initial_balance)
              ? Math.max(state.initial_balance, 0)
              : 0;
          return sum + value;
        }, 0);
        const liveCapital = reporting.reduce((sum, state) => {
          const value =
            typeof state.balance === "number" && Number.isFinite(state.balance)
              ? Math.max(state.balance, 0)
              : 0;
          return sum + value;
        }, 0);
        portfolioSummaryCapital.textContent = `Target ${formatNumber(
          totalInitial,
        )}  Live ${formatNumber(liveCapital)}`;

        if (!reporting.length) {
          const pausedSuffix = pausedStates.length
            ? `  Paused ${pausedStates.length}`
            : "";
          portfolioSummaryPositions.textContent = `Awaiting live positions${pausedSuffix}`;
        } else {
          const positionCounts = reporting.reduce(
            (acc, state) => {
              const key = (state.position || "FLAT").toUpperCase();
              acc[key] = (acc[key] || 0) + 1;
              return acc;
            },
            { LONG: 0, SHORT: 0, FLAT: 0 },
          );
          const pausedSuffix = pausedStates.length
            ? `  Paused ${pausedStates.length}`
            : "";
          portfolioSummaryPositions.textContent = `Long ${positionCounts.LONG}  Short ${positionCounts.SHORT}  Flat ${positionCounts.FLAT}${pausedSuffix}`;
        }

        const pnlLeaders = reporting
          .filter(
            (state) =>
              typeof state.unrealized_pnl_pct === "number" &&
              Number.isFinite(state.unrealized_pnl_pct),
          )
          .sort((a, b) => b.unrealized_pnl_pct - a.unrealized_pnl_pct);
        const leader = pnlLeaders[0];
        const laggard = pnlLeaders[pnlLeaders.length - 1];

        portfolioSummaryLeaders.textContent = leader
          ? `${leader.symbol} ${formatSignedPercent(leader.unrealized_pnl_pct)}`
          : "No reporting leaders yet.";
        portfolioSummaryLaggards.textContent = laggard
          ? `${laggard.symbol} ${formatSignedPercent(laggard.unrealized_pnl_pct)}`
          : "No reporting laggards yet.";

        if (portfolioSummaryGuard) {
          portfolioSummaryGuard.textContent = pausedStates.length
            ? `${pausedStates.length} paused`
            : "All running";
        }
        if (portfolioSummaryGuardNote) {
          portfolioSummaryGuardNote.textContent = pausedStates.length
            ? "Manual circuit breaker engaged on volatile markets."
            : "Pause bots instantly when volatility spikes.";
        }
        if (portfolioGuardList) {
          if (!pausedStates.length) {
            portfolioGuardList.innerHTML =
              '<li class="status-subtle">No manual pauses logged.</li>';
          } else {
            const items = pausedStates.slice(0, 3).map((state) => {
              const timing = formatRelativeTime(state.pause_updated_at);
              const timingText = timing ? `  ${timing}` : "";
              const reason = state.pause_reason
                ? escapeHtml(state.pause_reason)
                : "Manual pause";
              return `<li><strong>${escapeHtml(state.symbol || "-")}</strong>${timingText}<br /><span class="status-subtle">${reason}</span></li>`;
            });
            portfolioGuardList.innerHTML = items.join("");
            if (pausedStates.length > 3) {
              portfolioGuardList.innerHTML += `<li class="status-subtle">+${pausedStates.length - 3} more paused.</li>`;
            }
          }
        }
      }

      function renderPortfolioStatuses(statuses, { preview } = { preview: false }) {
        portfolioStatusError.textContent = "";

        const normalized = Array.isArray(statuses) ? statuses : [];
        const sorted = [...normalized].sort((a, b) =>
          (a.symbol || "").localeCompare(b.symbol || ""),
        );
        latestPortfolioStatuses = sorted.map((state) => ({ ...state }));

        if (!normalized.length) {
          portfolioStatusGrid.innerHTML = "";
          portfolioStatusCount.textContent = "";
          portfolioStatusEmpty.classList.remove("hidden");
          portfolioStatusEmpty.textContent = preview
            ? "Preview portfolio bots animate once data is available."
            : "No portfolio bots have published a state file yet.";
          renderPortfolioSummary([], preview);
          drawPortfolioAllocationChart([], preview);
          return;
        }

        portfolioStatusEmpty.classList.add("hidden");
        const reportingCount = normalized.filter((state) => !state.is_placeholder).length;
        portfolioStatusCount.textContent = `${reportingCount} reporting / ${normalized.length} configured`;

        const cards = sorted
          .map((state) => {
            const symbolLabel = escapeHtml(state.symbol || "-");
            const confidenceSource =
              typeof state.confidence === "number"
                ? state.confidence
                : typeof state.ai_confidence === "number"
                ? state.ai_confidence
                : null;
            const confidenceText = formatRatioPercent(confidenceSource);
            const riskText = formatPercent(state.risk_per_trade_pct);
            const sizeText = formatNumber(state.position_size, 4);
            const pnLText = formatSignedPercent(state.unrealized_pnl_pct);
            const entryText = formatNumber(state.entry_price);
            const startingCapital = formatNumber(
              typeof state.initial_balance === "number"
                ? state.initial_balance
                : state.balance,
            );
            const lastSignal = state.last_signal
              ? `Last signal: ${escapeHtml(state.last_signal)}`
              : "Last signal: -";
            const aiActionText = state.ai_action
              ? escapeHtml(state.ai_action)
              : null;
            const aiLine = aiActionText
              ? `<div class="portfolio-ai">AI: ${aiActionText}  ${formatRatioPercent(
                  state.ai_confidence
                )}</div>`
              : "";
            const dataDir = state.data_directory
              ? `${escapeHtml(state.data_directory)}`
              : "";
            const assetType = state.asset_type
              ? escapeHtml(titleCase(state.asset_type))
              : null;
            const timeframe = state.timeframe
              ? escapeHtml(state.timeframe.toUpperCase())
              : null;
            const allocation =
              typeof state.allocation_pct === "number"
                ? `${state.allocation_pct.toFixed(1)}% alloc`
                : null;
            const metaLine = [assetType, timeframe, allocation]
              .filter(Boolean)
              .join("  ");
            const modeBadge =
              typeof state.paper_mode === "boolean"
                ? `<span class="portfolio-mode ${state.paper_mode ? "paper" : "live"}">${
                    state.paper_mode ? "Paper" : "Live"
                  }</span>`
                : "";
            const placeholderBadge = state.is_placeholder
              ? '<span class="portfolio-placeholder-badge">Awaiting data</span>'
              : "";
            const isPaused = Boolean(state.is_paused);
            const pauseBadge = isPaused
              ? '<span class="portfolio-pause-pill">Paused</span>'
              : "";
            const badges = [modeBadge, placeholderBadge, pauseBadge]
              .filter(Boolean)
              .join("");
            const pauseTiming = formatRelativeTime(state.pause_updated_at);
            const pauseReason = state.pause_reason
              ? escapeHtml(state.pause_reason)
              : null;
            let noteText;
            let noteClass = "portfolio-note";
            if (state.is_placeholder) {
              noteText = "Awaiting first heartbeat from bot.";
              noteClass = "portfolio-note placeholder";
            } else if (isPaused) {
              const timingText = pauseTiming ? `  ${pauseTiming}` : "";
              const reasonText = pauseReason ? `  ${pauseReason}` : "";
              noteText = `Trading paused${timingText}${reasonText}`;
              noteClass = "portfolio-note paused";
            } else {
              noteText = lastSignal;
            }
            const stopLossText =
              typeof state.stop_loss_pct === "number"
                ? formatPercent(state.stop_loss_pct * 100)
                : "-";
            const takeProfitText =
              typeof state.take_profit_pct === "number"
                ? formatPercent(state.take_profit_pct * 100)
                : "-";
            const pauseButtonAction = isPaused ? "resume" : "pause";
            const pauseButtonLabel = isPaused ? "Resume Trading" : "Pause Trading";
            const pauseButtonClass = isPaused ? "resume" : "pause";
            const controlDisabled = isPreviewMode ? "disabled" : "";
            const pauseReasonAttr = pauseReason ? pauseReason : "";
            const guardHint = isPaused
              ? "Resume once markets calm down."
              : "Use to halt orders during turbulence.";

            return `
              <div class="portfolio-position-card">
                <div class="portfolio-card-header">
                  <div>
                    <div class="portfolio-symbol">${symbolLabel}</div>
                    ${metaLine ? `<div class="portfolio-meta">${metaLine}</div>` : ""}
                    <div class="status-subtle">${dataDir}</div>
                  </div>
                  <div class="portfolio-card-actions">
                    ${badges ? `<div class="portfolio-card-badges">${badges}</div>` : ""}
                    <span class="portfolio-position">${state.position || "-"}</span>
                  </div>
                </div>
                <div class="portfolio-metrics">
                  <div class="portfolio-row">
                    <span class="portfolio-label">Balance</span>
                    <span class="portfolio-value">${formatNumber(state.balance)}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Starting</span>
                    <span class="portfolio-value">${startingCapital}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Unrealized PnL</span>
                    <span class="portfolio-value">${pnLText}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Entry</span>
                    <span class="portfolio-value">${entryText}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Position Size</span>
                    <span class="portfolio-value">${sizeText}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Risk / Conf.</span>
                    <span class="portfolio-value">${riskText}  ${confidenceText}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">AI Action</span>
                    <span class="portfolio-value">${aiActionText || "-"}</span>
                  </div>
                  <div class="portfolio-row">
                    <span class="portfolio-label">Stop / Take</span>
                    <span class="portfolio-value">${stopLossText}  ${takeProfitText}</span>
                  </div>
                </div>
                <p class="${noteClass}">${noteText}</p>
                ${aiLine}
                <div class="portfolio-guard-controls">
                  <button
                    class="portfolio-toggle ${pauseButtonClass}"
                    data-symbol="${symbolLabel}"
                    data-action="${pauseButtonAction}"
                    data-current-reason="${pauseReasonAttr}"
                    ${controlDisabled}
                  >
                    ${pauseButtonLabel}
                  </button>
                  <p class="portfolio-guard-hint">${guardHint}</p>
                  ${pauseTiming ? `<p class="portfolio-guard-hint">Paused ${pauseTiming}</p>` : ""}
                  ${pauseReason ? `<p class="portfolio-guard-hint portfolio-pause-reason">${pauseReason}</p>` : ""}
                </div>
              </div>
            `;
          })
          .join("");

        portfolioStatusGrid.innerHTML = cards;
        renderPortfolioSummary(sorted, preview);
        drawPortfolioAllocationChart(latestPortfolioStatuses, preview);
      }

      portfolioStatusGrid.addEventListener("click", (event) => {
        const button = event.target.closest(".portfolio-toggle");
        if (!button) {
          return;
        }
        if (isPreviewMode) {
          portfolioStatusError.textContent =
            "Pause/resume controls are disabled in preview mode.";
          return;
        }
        const symbol = button.dataset.symbol;
        if (!symbol) {
          return;
        }
        const action = button.dataset.action;
        const defaultReason = button.dataset.currentReason || "";
        if (action === "pause") {
          let reason = window.prompt(
            "Reason for pausing this bot? (optional)",
            defaultReason || "Manual dashboard pause",
          );
          if (reason === null) {
            return;
          }
          reason = reason.trim();
          sendPortfolioControlUpdate(symbol, true, reason || null, button);
        } else {
          sendPortfolioControlUpdate(symbol, false, null, button);
        }
      });

      async function refreshPortfolioStatusesOnly() {
        try {
          const portfolioStatuses = await fetchJSON("/portfolio/status").catch(
            () => [],
          );
          renderPortfolioStatuses(portfolioStatuses, { preview: false });
        } catch (error) {
          console.error(error);
          portfolioStatusError.textContent =
            "Unable to refresh portfolio states after updating controls.";
        }
      }

      async function sendPortfolioControlUpdate(symbol, paused, reason, button) {
        if (!button) {
          return;
        }
        const previousLabel = button.textContent;
        button.disabled = true;
        button.textContent = paused ? "Pausing..." : "Resuming...";
        try {
          const response = await fetch("/portfolio/controls", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ symbol, paused, reason }),
          });
          if (!response.ok) {
            throw new Error(`Control update failed with status ${response.status}`);
          }
          await refreshPortfolioStatusesOnly();
        } catch (error) {
          console.error(error);
          portfolioStatusError.textContent =
            "Unable to update safety controls. Ensure the API is reachable.";
        } finally {
          button.disabled = false;
          button.textContent = previousLabel;
        }
      }

      function formatPlaybookHorizon(horizon) {
        if (!horizon) {
          return "";
        }
        const label = `${titleCase(horizon.label)} (${horizon.timeframe})`;
        const returnText = formatSignedPercent(horizon.total_return_pct);
        const finalValue = formatNumber(horizon.final_balance);
        const sharpe =
          typeof horizon.sharpe_ratio === "number" && Number.isFinite(horizon.sharpe_ratio)
            ? horizon.sharpe_ratio.toFixed(2)
            : "--";
        const winRate = formatPercent(horizon.win_rate, 1);
        const trades =
          typeof horizon.trades === "number" && Number.isFinite(horizon.trades)
            ? horizon.trades
            : "--";
        const macroBiasText =
          typeof horizon.macro_bias === "number" && Number.isFinite(horizon.macro_bias)
            ? ` | Macro ${horizon.macro_bias.toFixed(2)}`
            : "";
        return `<li><span class="playbook-horizon-label">${label}</span>  Return ${returnText}  Final ${finalValue}  Sharpe ${sharpe}  Win ${winRate}  Trades ${trades}${macroBiasText}</li>`;
      }

      function renderAssetPlaybook(asset) {
        const macroSummaryText = asset.macro_summary || "Macro stance unavailable.";
        const drivers = (asset.macro_drivers || []).filter(Boolean).slice(0, 3);
        const driverLine = drivers.length
          ? `<p class="status-subtle">${drivers.join("  ")}</p>`
          : "";
        const horizons = (asset.horizons || []).map((horizon) => formatPlaybookHorizon(horizon)).filter(Boolean);
        const horizonList =
          horizons.length
            ? horizons.join("")
            : '<li class="status-subtle">No horizon analytics recorded yet.</li>';
        const notes = (asset.notes || []).filter(Boolean);
        const rateNote = asset.macro_interest_rate_outlook
          ? `Rate outlook: ${asset.macro_interest_rate_outlook}`
          : null;
        const politicsNote = asset.macro_political_risk ? `Politics: ${asset.macro_political_risk}` : null;
        const combinedNotes = [...notes, rateNote, politicsNote].filter(Boolean);
        const notesMarkup =
          combinedNotes.length
            ? combinedNotes.map((note) => `<li>${note}</li>`).join("")
            : '<li class="status-subtle">No qualitative notes yet.</li>';

        return `
          <div class="playbook-card">
            <header>
              <span class="playbook-symbol">${asset.symbol}</span>
              <span class="status-subtle">${formatBias(asset.macro_bias)}</span>
            </header>
            <p class="status-subtle">${macroSummaryText}</p>
            ${driverLine}
            <ul class="playbook-horizons">
              ${horizonList}
            </ul>
            <ul class="playbook-notes">
              ${notesMarkup}
            </ul>
          </div>
        `;
      }

      function renderPlaybookGroup(container, assets, preview) {
        if (!assets || !assets.length) {
          container.innerHTML = '<p class="status-subtle">No assets evaluated yet.</p>';
          return;
        }
        container.innerHTML = assets.map((asset) => renderAssetPlaybook(asset)).join("\n");
      }

      function renderPlaybook(playbook, { preview } = { preview: false }) {
        playbookError.textContent = "";
        if (!playbook) {
          playbookUpdated.textContent = preview
            ? "Preview playbook not generated yet."
            : "Portfolio playbook unavailable.";
          playbookHighlights.innerHTML = "";
          renderPlaybookGroup(playbookCommodities, [], preview);
          renderPlaybookGroup(playbookEquities, [], preview);
          if (!preview) {
            playbookError.textContent =
              "Unable to load the portfolio playbook. Ensure the bot has generated analytics.";
          }
          return;
        }

        const generatedAt = playbook.generated_at ? new Date(playbook.generated_at) : new Date();
        playbookUpdated.textContent = `Generated at ${generatedAt.toLocaleString()}`;

        const highlights = (playbook.highlights || []).filter(Boolean);
        playbookHighlights.innerHTML = highlights.length
          ? highlights.map((item) => `<span class="playbook-highlight">${item}</span>`).join("")
          : '<span class="status-subtle">No highlights logged yet.</span>';

        renderPlaybookGroup(playbookCommodities, playbook.commodities || [], preview);
        renderPlaybookGroup(playbookEquities, playbook.equities || [], preview);
      }

      function formatSignalAi(signal) {
        if (!signal.ai_action) {
          return "-";
        }
        const confidenceText =
          typeof signal.ai_confidence === "number"
            ? formatRatioPercent(signal.ai_confidence)
            : null;
        return confidenceText ? `${signal.ai_action} (${confidenceText})` : signal.ai_action;
      }

      function render(
        status,
        signals,
        equity,
        strategy,
        ai,
        macro,
        playbook,
        portfolioStatuses,
        { preview } = { preview: false },
      ) {
        statusError.textContent = "";

        statusSymbol.textContent = status.symbol ?? "-";
        statusPosition.textContent = status.position ?? "-";
        statusBalance.textContent = formatNumber(status.balance);
        statusEntry.textContent = `Entry: ${formatNumber(status.entry_price)}`;
        statusPnL.textContent = formatPercent(status.unrealized_pnl_pct);
        statusSignal.textContent = status.last_signal ?? "-";
        statusConfidence.textContent = formatRatioPercent(status.confidence);
        statusRisk.textContent = formatPercent(status.risk_per_trade_pct);

        const timestamp = status.timestamp ? new Date(status.timestamp) : new Date();
        const prefix = preview ? "Preview mode  " : "Last updated: ";
        lastUpdated.textContent = `${prefix}${timestamp.toLocaleTimeString()}`;

        if (!signals.length) {
          signalsBody.innerHTML = '<tr><td colspan="5">No signals yet.</td></tr>';
        } else {
          signalsBody.innerHTML = signals
            .map(
              (signal) => `
                <tr>
                  <td>${new Date(signal.timestamp).toLocaleString()}</td>
                  <td>${signal.decision}</td>
                  <td>${formatRatioPercent(signal.confidence)}</td>
                  <td>${formatSignalAi(signal)}</td>
                  <td>${formatPercent(signal.ai_expected_move_pct)}</td>
                  <td>${signal.reason}</td>
                </tr>
              `,
            )
            .join("");
        }

        drawEquityCurve(equity);
        renderStrategy(strategy);
        renderAI(ai, { preview });
        renderMacro(macro, { preview });
        renderPortfolioStatuses(portfolioStatuses, { preview });
        renderPlaybook(playbook, { preview });
      }

      async function submitQuestion(question) {
        aiQuestionFeedback.textContent = "";
        aiQuestionSubmit.disabled = true;
        const previousText = aiQuestionSubmit.textContent;
        aiQuestionSubmit.textContent = "Thinking...";
        try {
          const response = await fetch("/ai/question", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ question }),
          });
          if (!response.ok) {
            throw new Error(`AI request failed with status ${response.status}`);
          }
          const data = await response.json();
          aiAnswer.textContent = data.answer;
          aiQuestionInput.value = "";
        } catch (error) {
          console.error(error);
          aiQuestionFeedback.textContent =
            "Unable to fetch an AI answer. Ensure the API is running.";
        } finally {
          aiQuestionSubmit.disabled = false;
          aiQuestionSubmit.textContent = previousText;
        }
      }

      function buildPreviewAnswer(question, ai) {
        const text = question.toLowerCase();
        const action = ai && ai.recommended_action ? ai.recommended_action : "FLAT";
        const confidence = ai && typeof ai.confidence === "number" ? `${(ai.confidence * 100).toFixed(1)}%` : "--";
        const expectedMove = ai && typeof ai.expected_move_pct === "number" ? `${ai.expected_move_pct.toFixed(2)}%` : "--";

        if (text.includes("buy") || text.includes("long")) {
          return `Preview guidance: look for the fast EMA crossing above the slow EMA with RSI below ${PREVIEW_STRATEGY.rsi_overbought}. AI currently favours ${action} with ${confidence} confidence.`;
        }
        if (text.includes("sell") || text.includes("short")) {
          return `Preview guidance: short triggers arrive when EMA fast slips under EMA slow while RSI is above ${PREVIEW_STRATEGY.rsi_oversold}. AI stance: ${action} with expected move ${expectedMove}.`;
        }
        if (text.includes("risk") || text.includes("stop") || text.includes("take")) {
          return `Preview risk settings: stop-loss ${(
            PREVIEW_STRATEGY.stop_loss_pct * 100
          ).toFixed(2)}% and take-profit ${(PREVIEW_STRATEGY.take_profit_pct * 100).toFixed(2)}%. Risk per trade ${PREVIEW_STRATEGY.risk_per_trade_pct}% of balance.`;
        }
        if (text.includes("ai") || text.includes("model") || text.includes("prob")) {
          return `Preview AI leans ${action} with ${confidence} confidence and expects ${expectedMove} move.`;
        }
        return `Preview bot watches ${PREVIEW_STRATEGY.symbol} on ${PREVIEW_STRATEGY.timeframe} candles using EMA ${PREVIEW_STRATEGY.ema_fast}/${PREVIEW_STRATEGY.ema_slow} and RSI ${PREVIEW_STRATEGY.rsi_period}. Ask about buy, sell, risk, macro, or AI for focused tips.`;
      }

      aiQuestionForm.addEventListener("submit", (event) => {
        event.preventDefault();
        const question = aiQuestionInput.value.trim();
        if (!question) {
          aiQuestionFeedback.textContent = "Enter a question to get an answer.";
          return;
        }
        aiQuestionFeedback.textContent = "";
        if (isPreviewMode) {
          aiAnswer.textContent = buildPreviewAnswer(question, latestAiSnapshot);
          aiQuestionInput.value = "";
          return;
        }
        submitQuestion(question);
      });

      window.addEventListener("resize", () => {
        drawEquityCurve(latestEquityPoints);
        drawAiProbabilityChart(latestAiSnapshot);
        drawPortfolioAllocationChart(latestPortfolioStatuses, isPreviewMode);
      });

      async function fetchJSON(path) {
        const response = await fetch(path);
        if (!response.ok) {
          throw new Error(`Request failed with status ${response.status}`);
        }
        return response.json();
      }

      async function refresh() {
        try {
          const [status, signals, equity, strategy, ai, macro, playbook, portfolioStatuses] =
            await Promise.all([
              fetchJSON("/status"),
              fetchJSON("/signals?limit=20"),
              fetchJSON("/equity"),
              fetchJSON("/strategy"),
              fetchJSON("/ai/prediction").catch(() => null),
              fetchJSON("/macro/insights").catch(() => null),
              fetchJSON("/portfolio/playbook").catch(() => null),
              fetchJSON("/portfolio/status").catch(() => []),
            ]);

          render(status, signals, equity, strategy, ai, macro, playbook, portfolioStatuses, {
            preview: false,
          });
        } catch (error) {
          console.error(error);
          statusError.textContent =
            "Unable to load live data. Ensure the bot is running and producing state files.";
          portfolioStatusError.textContent =
            "Portfolio states unavailable. Verify each asset is writing data_dir/state.json.";
        }
      }

      function renderPreview() {
        const now = Date.now();
        const oscillation = Math.sin(now / 4000);
        const secondary = Math.cos(now / 5000);

        const status = {
          ...PREVIEW_STATE,
          timestamp: new Date(now).toISOString(),
          unrealized_pnl_pct: PREVIEW_STATE.unrealized_pnl_pct + oscillation * 0.35,
          balance: PREVIEW_STATE.balance + oscillation * 45,
          confidence: Math.min(Math.max(PREVIEW_STATE.confidence + secondary * 0.06, 0), 1),
        };

        const signals = PREVIEW_SIGNALS.map((signal, index) => ({
          ...signal,
          timestamp: new Date(now - index * 90_000).toISOString(),
        }));

        const equity = PREVIEW_EQUITY_BASE.map((base, index) => ({
          value: base + Math.sin(now / 3200 + index / 2.5) * 16,
          timestamp: new Date(now - (PREVIEW_EQUITY_BASE.length - index) * 60_000).toISOString(),
        }));

        const ai = { ...PREVIEW_AI };
        const leaningLong = oscillation >= 0;
        ai.recommended_action = leaningLong ? "LONG" : "SHORT";
        ai.confidence = Math.min(Math.max(PREVIEW_AI.confidence + oscillation * 0.05, 0.2), 0.95);
        ai.expected_move_pct =
          (leaningLong ? 1 : -1) * (PREVIEW_AI.expected_move_pct + secondary * 0.18);
        const previewProbLong = Math.min(
          Math.max(ai.confidence - (leaningLong ? 0.05 : -0.1), 0.05),
          0.93,
        );
        const previewProbShort = Math.min(
          Math.max(leaningLong ? 0.18 - oscillation * 0.08 : ai.confidence - 0.04, 0.05),
          0.9,
        );
        const previewProbFlat = Math.max(0.02, 1 - (previewProbLong + previewProbShort));
        ai.probability_long = previewProbLong;
        ai.probability_short = previewProbShort;
        ai.probability_flat = previewProbFlat;
        const direction = leaningLong ? "upside" : "downside";
        ai.summary = `Model leans ${direction} with ${(ai.confidence * 100).toFixed(
          1,
        )}% confidence driven by EMA gap ${(
          PREVIEW_AI.features.ema_gap_pct + oscillation * 0.2
        ).toFixed(2)}% and momentum ${(
          PREVIEW_AI.features.momentum_pct + secondary * 0.15
        ).toFixed(2)}%. Expected move: ${ai.expected_move_pct.toFixed(2)}%`;
        ai.features = {
          ema_gap_pct: PREVIEW_AI.features.ema_gap_pct + oscillation * 0.2,
          momentum_pct: PREVIEW_AI.features.momentum_pct + secondary * 0.15,
          rsi_distance_from_mid:
            PREVIEW_AI.features.rsi_distance_from_mid + oscillation * 1.8,
          volatility_pct: PREVIEW_AI.features.volatility_pct + secondary * 0.12,
        };

        const macro = { ...PREVIEW_MACRO };
        macro.bias_score = PREVIEW_MACRO.bias_score + secondary * 0.08;
        macro.confidence = Math.min(
          Math.max(PREVIEW_MACRO.confidence + oscillation * 0.07, 0),
          1,
        );
        macro.summary = `Macro bias is ${macro.bias_score > 0 ? "bullish" : macro.bias_score < 0 ? "bearish" : "balanced"} (${macro.bias_score.toFixed(
          2,
        )}) with confidence ${(macro.confidence * 100).toFixed(1)}%. Preview catalysts animate to show how political and rate headlines tilt the playbook.`;
        macro.events = PREVIEW_MACRO.events.map((event, index) => ({
          ...event,
          timestamp: new Date(now - index * 120_000).toISOString(),
        }));

        const playbook = JSON.parse(JSON.stringify(PREVIEW_PLAYBOOK));
        playbook.generated_at = new Date(now).toISOString();
        playbook.commodities.forEach((asset, assetIndex) => {
          const biasShift = Math.sin(now / 3600 + assetIndex) * 0.05;
          const confidenceShift = Math.cos(now / 4100 + assetIndex) * 0.06;
          asset.macro_bias = parseFloat((asset.macro_bias + biasShift).toFixed(2));
          asset.macro_confidence = Math.min(
            Math.max(asset.macro_confidence + confidenceShift, 0),
            1,
          );
          asset.horizons.forEach((horizon, horizonIndex) => {
            const tweak = Math.sin(now / 4300 + horizonIndex + assetIndex * 0.4) * 0.35;
            horizon.total_return_pct = parseFloat((horizon.total_return_pct + tweak).toFixed(2));
            horizon.final_balance = parseFloat(
              (horizon.initial_balance * (1 + horizon.total_return_pct / 100)).toFixed(2),
            );
            horizon.annualized_return_pct = parseFloat(
              (horizon.annualized_return_pct + tweak * 6).toFixed(2),
            );
            horizon.macro_bias = asset.macro_bias;
          });
        });
        playbook.equities.forEach((asset, assetIndex) => {
          const biasShift = Math.cos(now / 3700 + assetIndex) * 0.04;
          const confidenceShift = Math.sin(now / 3900 + assetIndex) * 0.05;
          asset.macro_bias = parseFloat((asset.macro_bias + biasShift).toFixed(2));
          asset.macro_confidence = Math.min(
            Math.max(asset.macro_confidence + confidenceShift, 0),
            1,
          );
          asset.horizons.forEach((horizon, horizonIndex) => {
            const tweak = Math.cos(now / 4500 + horizonIndex + assetIndex * 0.5) * 0.28;
            horizon.total_return_pct = parseFloat((horizon.total_return_pct + tweak).toFixed(2));
            horizon.final_balance = parseFloat(
              (horizon.initial_balance * (1 + horizon.total_return_pct / 100)).toFixed(2),
            );
            horizon.annualized_return_pct = parseFloat(
              (horizon.annualized_return_pct + tweak * 5).toFixed(2),
            );
            horizon.macro_bias = asset.macro_bias;
          });
        });

        const portfolioStatuses = PREVIEW_PORTFOLIO_STATES.map((state, index) => {
          const confidenceShift = Math.sin(now / 3600 + index) * 0.08;
          const pnlShift = Math.cos(now / 3700 + index) * 0.25;
          const balanceShift = Math.sin(now / 3300 + index) * 65;
          return {
            ...state,
            timestamp: new Date(now - index * 45_000).toISOString(),
            balance: state.balance + balanceShift,
            unrealized_pnl_pct: parseFloat((state.unrealized_pnl_pct + pnlShift).toFixed(2)),
            confidence: Math.min(
              Math.max((state.confidence ?? 0.5) + confidenceShift, 0),
              1,
            ),
            ai_confidence: Math.min(
              Math.max((state.ai_confidence ?? 0.5) + confidenceShift * 0.8, 0),
              1,
            ),
            position_size: Math.max(state.position_size + confidenceShift * 0.2, 0),
          };
        });

        render(
          status,
          signals,
          equity,
          PREVIEW_STRATEGY,
          ai,
          macro,
          playbook,
          portfolioStatuses,
          { preview: true },
        );
      }

      if (isPreviewMode) {
        renderPreview();
        setInterval(renderPreview, 4000);
      } else {
        refresh();
        setInterval(refresh, 5000);
      }
    </script>
  </body>
</html>
